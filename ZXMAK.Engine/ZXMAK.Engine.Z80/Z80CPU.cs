using System;

namespace ZXMAK.Engine.Z80;

public class Z80CPU
{
	private delegate void XFXOPDO(byte cmd);

	private delegate void FXCBOPDO(byte cmd, ushort adr);

	private delegate void ALUALGORITHM(byte src);

	public delegate byte MEMREADER(ushort ADDR);

	public ulong Tact;

	public Registers regs = new Registers();

	public bool HALTED;

	public bool IFF1;

	public bool IFF2;

	public byte IM;

	public bool BlockINT;

	public OPFX FX;

	public OPXFX XFX;

	public bool INT;

	public bool NMI;

	public bool RST;

	public byte FreeBUS = byte.MaxValue;

	public OnRDMEM ReadMemory;

	public OnWRMEM WriteMemory;

	public OnRDPORT ReadPort;

	public OnWRPORT WritePort;

	public OnCALLBACK OnCycle;

	private XFXOPDO[] opTABLE;

	private XFXOPDO[] fxopTABLE;

	private XFXOPDO[] edopTABLE;

	private XFXOPDO[] cbopTABLE;

	private FXCBOPDO[] fxcbopTABLE;

	private static byte[] conds = new byte[4] { 64, 1, 4, 128 };

	private static ALUALGORITHM[] alualg;

	private ALUALGORITHM[] alulogic;

	private static readonly string[] DirectZ80Code = new string[256]
	{
		"NOP", "LD     BC,$W", "LD     (BC),A", "INC    BC", "INC    B", "DEC    B", "LD     B,$N", "RLCA", "EX     AF,AF'", "ADD    HL,BC",
		"LD     A,(BC)", "DEC    BC", "INC    C", "DEC    C", "LD     C,$N", "RRCA", "DJNZ   $DIS", "LD     DE,$W", "LD     (DE),A", "INC    DE",
		"INC    D", "DEC    D", "LD     D,$N", "RLA", "JR     $DIS", "ADD    HL,DE", "LD     A,(DE)", "DEC    DE", "INC    E", "DEC    E",
		"LD     E,$N", "RRA", "JR     NZ,$DIS", "LD     HL,$W", "LD     ($W),HL", "INC    HL", "INC    H", "DEC    H", "LD     H,$N", "DAA",
		"JR     Z,$DIS", "ADD    HL,HL", "LD     HL,($W)", "DEC    HL", "INC    L", "DEC    L", "LD     L,$N", "CPL", "JR     NC,$DIS", "LD     SP,$W",
		"LD     ($W),A", "INC    SP", "INC    (HL)", "DEC    (HL)", "LD     (HL),$N", "SCF", "JR     C,$DIS", "ADD    HL,SP", "LD     A,($W)", "DEC    SP",
		"INC    A", "DEC    A", "LD     A,$N", "CCF", "LD     B,B", "LD     B,C", "LD     B,D", "LD     B,E", "LD     B,H", "LD     B,L",
		"LD     B,(HL)", "LD     B,A", "LD     C,B", "LD     C,C", "LD     C,D", "LD     C,E", "LD     C,H", "LD     C,L", "LD     C,(HL)", "LD     C,A",
		"LD     D,B", "LD     D,C", "LD     D,D", "LD     D,E", "LD     D,H", "LD     D,L", "LD     D,(HL)", "LD     D,A", "LD     E,B", "LD     E,C",
		"LD     E,D", "LD     E,E", "LD     E,H", "LD     E,L", "LD     E,(HL)", "LD     E,A", "LD     H,B", "LD     H,C", "LD     H,D", "LD     H,E",
		"LD     H,H", "LD     H,L", "LD     H,(HL)", "LD     H,A", "LD     L,B", "LD     L,C", "LD     L,D", "LD     L,E", "LD     L,H", "LD     L,L",
		"LD     L,(HL)", "LD     L,A", "LD     (HL),B", "LD     (HL),C", "LD     (HL),D", "LD     (HL),E", "LD     (HL),H", "LD     (HL),L", "HALT", "LD     (HL),A",
		"LD     A,B", "LD     A,C", "LD     A,D", "LD     A,E", "LD     A,H", "LD     A,L", "LD     A,(HL)", "LD     A,A", "ADD    A,B", "ADD    A,C",
		"ADD    A,D", "ADD    A,E", "ADD    A,H", "ADD    A,L", "ADD    A,(HL)", "ADD    A,A", "ADC    A,B", "ADC    A,C", "ADC    A,D", "ADC    A,E",
		"ADC    A,H", "ADC    A,L", "ADC    A,(HL)", "ADC    A,A", "SUB    B", "SUB    C", "SUB    D", "SUB    E", "SUB    H", "SUB    L",
		"SUB    (HL)", "SUB    A", "SBC    A,B", "SBC    A,C", "SBC    A,D", "SBC    A,E", "SBC    A,H", "SBC    A,L", "SBC    A,(HL)", "SBC    A,A",
		"AND    B", "AND    C", "AND    D", "AND    E", "AND    H", "AND    L", "AND    (HL)", "AND    A", "XOR    B", "XOR    C",
		"XOR    D", "XOR    E", "XOR    H", "XOR    L", "XOR    (HL)", "XOR    A", "OR     B", "OR     C", "OR     D", "OR     E",
		"OR     H", "OR     L", "OR     (HL)", "OR     A", "CP     B", "CP     C", "CP     D", "CP     E", "CP     H", "CP     L",
		"CP     (HL)", "CP     A", "RET    NZ", "POP    BC", "JP     NZ,$W", "JP     $W", "CALL   NZ,$W", "PUSH   BC", "ADD    A,$N", "RST    $T",
		"RET    Z", "RET", "JP     Z,$W", "*CB", "CALL   Z,$W", "CALL   $W", "ADC    A,$N", "RST    $T", "RET    NC", "POP    DE",
		"JP     NC,$W", "OUT    ($N),A", "CALL   NC,$W", "PUSH   DE", "SUB    $N", "RST    $T", "RET    C", "EXX", "JP     C,$W", "IN     A,($N)",
		"CALL   C,$W", "*IX", "SBC    A,$N", "RST    $T", "RET    PO", "POP    HL", "JP     PO,$W", "EX     (SP),HL", "CALL   PO,$W", "PUSH   HL",
		"AND    $N", "RST    $T", "RET    PE", "JP     (HL)", "JP     PE,$W", "EX     DE,HL", "CALL   PE,$W", "*ED", "XOR    $N", "RST    $T",
		"RET    P", "POP    AF", "JP     P,$W", "DI", "CALL   P,$W", "PUSH   AF", "OR     $N", "RST    $T", "RET    M", "LD     SP,HL",
		"JP     M,$W", "EI", "CALL   M,$W", "*IY", "CP     $N", "RST    $T"
	};

	private static readonly string[] CBhZ80Code = new string[256]
	{
		"RLC    B", "RLC    C", "RLC    D", "RLC    E", "RLC    H", "RLC    L", "RLC    (HL)", "RLC    A", "RRC    B", "RRC    C",
		"RRC    D", "RRC    E", "RRC    H", "RRC    L", "RRC    (HL)", "RRC    A", "RL     B", "RL     C", "RL     D", "RL     E",
		"RL     H", "RL     L", "RL     (HL)", "RL     A", "RR     B", "RR     C", "RR     D", "RR     E", "RR     H", "RR     L",
		"RR     (HL)", "RR     A", "SLA    B", "SLA    C", "SLA    D", "SLA    E", "SLA    H", "SLA    L", "SLA    (HL)", "SLA    A",
		"SRA    B", "SRA    C", "SRA    D", "SRA    E", "SRA    H", "SRA    L", "SRA    (HL)", "SRA    A", "*SLL   B", "*SLL   C",
		"*SLL   D", "*SLL   E", "*SLL   H", "*SLL   L", "*SLL   (HL)", "*SLL   A", "SRL    B", "SRL    C", "SRL    D", "SRL    E",
		"SRL    H", "SRL    L", "SRL    (HL)", "SRL    A", "BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L",
		"BIT    $S,(HL)", "BIT    $S,A", "BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L", "BIT    $S,(HL)", "BIT    $S,A",
		"BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L", "BIT    $S,(HL)", "BIT    $S,A", "BIT    $S,B", "BIT    $S,C",
		"BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L", "BIT    $S,(HL)", "BIT    $S,A", "BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E",
		"BIT    $S,H", "BIT    $S,L", "BIT    $S,(HL)", "BIT    $S,A", "BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L",
		"BIT    $S,(HL)", "BIT    $S,A", "BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L", "BIT    $S,(HL)", "BIT    $S,A",
		"BIT    $S,B", "BIT    $S,C", "BIT    $S,D", "BIT    $S,E", "BIT    $S,H", "BIT    $S,L", "BIT    $S,(HL)", "BIT    $S,A", "RES    $S,B", "RES    $S,C",
		"RES    $S,D", "RES    $S,E", "RES    $S,H", "RES    $S,L", "RES    $S,(HL)", "RES    $S,A", "RES    $S,B", "RES    $S,C", "RES    $S,D", "RES    $S,E",
		"RES    $S,H", "RES    $S,L", "RES    $S,(HL)", "RES    $S,A", "RES    $S,B", "RES    $S,C", "RES    $S,D", "RES    $S,E", "RES    $S,H", "RES    $S,L",
		"RES    $S,(HL)", "RES    $S,A", "RES    $S,B", "RES    $S,C", "RES    $S,D", "RES    $S,E", "RES    $S,H", "RES    $S,L", "RES    $S,(HL)", "RES    $S,A",
		"RES    $S,B", "RES    $S,C", "RES    $S,D", "RES    $S,E", "RES    $S,H", "RES    $S,L", "RES    $S,(HL)", "RES    $S,A", "RES    $S,B", "RES    $S,C",
		"RES    $S,D", "RES    $S,E", "RES    $S,H", "RES    $S,L", "RES    $S,(HL)", "RES    $S,A", "RES    $S,B", "RES    $S,C", "RES    $S,D", "RES    $S,E",
		"RES    $S,H", "RES    $S,L", "RES    $S,(HL)", "RES    $S,A", "RES    $S,B", "RES    $S,C", "RES    $S,D", "RES    $S,E", "RES    $S,H", "RES    $S,L",
		"RES    $S,(HL)", "RES    $S,A", "SET    $S,B", "SET    $S,C", "SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A",
		"SET    $S,B", "SET    $S,C", "SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A", "SET    $S,B", "SET    $S,C",
		"SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A", "SET    $S,B", "SET    $S,C", "SET    $S,D", "SET    $S,E",
		"SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A", "SET    $S,B", "SET    $S,C", "SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L",
		"SET    $S,(HL)", "SET    $S,A", "SET    $S,B", "SET    $S,C", "SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A",
		"SET    $S,B", "SET    $S,C", "SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A", "SET    $S,B", "SET    $S,C",
		"SET    $S,D", "SET    $S,E", "SET    $S,H", "SET    $S,L", "SET    $S,(HL)", "SET    $S,A"
	};

	private static readonly string[] EDhZ80Code = new string[256]
	{
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "IN     B,(C)", "OUT    (C),B", "SBC    HL,BC", "LD     ($W),BC", "NEG", "RETN",
		"IM     0", "LD     I,A", "IN     C,(C)", "OUT    (C),C", "ADC    HL,BC", "LD     BC,($W)", "*NEG", "RETI", "*IM    0", "LD     R,A",
		"IN     D,(C)", "OUT    (C),D", "SBC    HL,DE", "LD     ($W),DE", "*NEG", "*RETN", "IM     1", "LD     A,I", "IN     E,(C)", "OUT    (C),E",
		"ADC    HL,DE", "LD     DE,($W)", "*NEG", "*RETN", "IM     2", "LD     A,R", "IN     H,(C)", "OUT    (C),H", "SBC    HL,HL", "LD     ($W),HL",
		"*NEG", "*RETN", "*IM    0", "RRD", "IN     L,(C)", "OUT    (C),L", "ADC    HL,HL", "LD     HL,($W)", "*NEG", "*RETN",
		"*IM    0", "RLD", "*IN    (C)", "*OUT   (C),0", "SBC    HL,SP", "LD     ($W),SP", "*NEG", "*RETN", "*IM    1", "*NOP",
		"IN     A,(C)", "OUT    (C),A", "ADC    HL,SP", "LD     SP,($W)", "*NEG", "*RETN", "*IM    2", "*NOP", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"LDI", "CPI", "INI", "OUTI", "", "", "", "", "LDD", "CPD",
		"IND", "OUTD", "", "", "", "", "LDIR", "CPIR", "INIR", "OTIR",
		"", "", "", "", "LDDR", "CPDR", "INDR", "OTDR", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", ""
	};

	private static readonly string[] DDFDhZ80Code = new string[256]
	{
		"", "", "", "", "", "", "", "", "", "ADD    $R,BC",
		"", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "ADD    $R,DE", "", "", "", "",
		"", "", "", "LD     $R,$W", "LD     ($W),$R", "INC    $R", "*INC   $RH", "*DEC   $RH", "*LD    $RH,$N", "",
		"", "ADD    $R,$R", "LD     $R,($W)", "DEC    $R", "*INC   $RL", "*DEC   $RL", "*LD    $RL,$N", "", "", "",
		"", "", "INC    ($R$PLUS)", "DEC    ($R$PLUS)", "LD     ($R$PLUS),$N", "", "", "ADD    $R,SP", "", "",
		"", "", "", "", "", "", "", "", "*LD    B,$RH", "*LD    B,$RL",
		"LD     B,($R$PLUS)", "", "", "", "", "", "*LD    C,$RH", "*LD    C,$RL", "LD     C,($R$PLUS)", "",
		"", "", "", "", "*LD    D,$RH", "*LD    D,$RL", "LD     D,($R$PLUS)", "", "", "",
		"", "", "*LD    E,$RH", "*LD    E,$RL", "LD     E,($R$PLUS)", "", "*LD    $RH,B", "*LD    $RH,C", "*LD    $RH,D", "*LD    $RH,E",
		"*LD    $RH,$RH", "*LD    $RH,$RL", "LD     H,($R$PLUS)", "*LD    $RH,A", "*LD    $RL,B", "*LD    $RL,C", "*LD    $RL,D", "*LD    $RL,E", "*LD    $RL,$RH", "*LD    $RL,$RL",
		"LD     L,($R$PLUS)", "*LD    $RL,A", "LD     ($R$PLUS),B", "LD     ($R$PLUS),C", "LD     ($R$PLUS),D", "LD     ($R$PLUS),E", "LD     ($R$PLUS),H", "LD     ($R$PLUS),L", "", "LD     ($R$PLUS),A",
		"", "", "", "", "*LD    A,$RH", "*LD    A,$RL", "LD     A,($R$PLUS)", "", "", "",
		"", "", "*ADD   A,$RH", "*ADD   A,$RL", "ADD    A,($R$PLUS)", "", "", "", "", "",
		"*ADC   A,$RH", "*ADC   A,$RL", "ADC    A,($R$PLUS)", "", "", "", "", "", "*SUB   $RH", "*SUB   $RL",
		"SUB    ($R$PLUS)", "", "", "", "", "", "*SBC   A,$RH", "*SBC   A,$RL", "SBC    A,($R$PLUS)", "",
		"", "", "", "", "*AND   $RH", "*AND   $RL", "AND    ($R$PLUS)", "", "", "",
		"", "", "*XOR   $RH", "*XOR   $RL", "XOR    ($R$PLUS)", "", "", "", "", "",
		"*OR    $RH", "*OR    $RL", "OR     ($R$PLUS)", "", "", "", "", "", "*CP    $RH", "*CP    $RL",
		"CP     ($R$PLUS)", "", "", "", "", "", "", "", "", "",
		"", "", "", "*DD/FD,CB", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "",
		"", "*DD/FD,DD", "", "", "", "POP    $R", "", "EX     (SP),$R", "", "PUSH   $R",
		"", "", "", "JP     ($R)", "", "", "", "*DD/FD,ED", "", "",
		"", "", "", "", "", "", "", "", "", "LD     SP,$R",
		"", "", "", "*DD/FD,FD", "", ""
	};

	private static readonly string[] DDFDCBhZ80Code = new string[256]
	{
		"*RLC   B,($R$PLUS)", "*RLC   C,($R$PLUS)", "*RLC   D,($R$PLUS)", "*RLC   E,($R$PLUS)", "*RLC   H,($R$PLUS)", "*RLC   L,($R$PLUS)", "RLC    ($R$PLUS)", "*RLC   A,($R$PLUS)", "*RRC   B,($R$PLUS)", "*RRC   C,($R$PLUS)",
		"*RRC   D,($R$PLUS)", "*RRC   E,($R$PLUS)", "*RRC   H,($R$PLUS)", "*RRC   L,($R$PLUS)", "RRC    ($R$PLUS)", "*RRC   A,($R$PLUS)", "*RL    B,($R$PLUS)", "*RL    C,($R$PLUS)", "*RL    D,($R$PLUS)", "*RL    E,($R$PLUS)",
		"*RL    H,($R$PLUS)", "*RL    L,($R$PLUS)", "RL     ($R$PLUS)", "*RL    A,($R$PLUS)", "*RR    B,($R$PLUS)", "*RR    C,($R$PLUS)", "*RR    D,($R$PLUS)", "*RR    E,($R$PLUS)", "*RR    H,($R$PLUS)", "*RR    L,($R$PLUS)",
		"RR     ($R$PLUS)", "*RR    A,($R$PLUS)", "*SLA   B,($R$PLUS)", "*SLA   C,($R$PLUS)", "*SLA   D,($R$PLUS)", "*SLA   E,($R$PLUS)", "*SLA   H,($R$PLUS)", "*SLA   L,($R$PLUS)", "SLA    ($R$PLUS)", "*SLA   A,($R$PLUS)",
		"*SRA   B,($R$PLUS)", "*SRA   C,($R$PLUS)", "*SRA   D,($R$PLUS)", "*SRA   E,($R$PLUS)", "*SRA   H,($R$PLUS)", "*SRA   L,($R$PLUS)", "SRA    ($R$PLUS)", "*SRA   A,($R$PLUS)", "*SLL   B,($R$PLUS)", "*SLL   C,($R$PLUS)",
		"*SLL   D,($R$PLUS)", "*SLL   E,($R$PLUS)", "*SLL   H,($R$PLUS)", "*SLL   L,($R$PLUS)", "*SLL   ($R$PLUS)", "*SLL   A,($R$PLUS)", "*SRL   B,($R$PLUS)", "*SRL   C,($R$PLUS)", "*SRL   D,($R$PLUS)", "*SRL   E,($R$PLUS)",
		"*SRL   H,($R$PLUS)", "*SRL   L,($R$PLUS)", "SRL    ($R$PLUS)", "*SRL   A,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)",
		"BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)",
		"*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)",
		"*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)",
		"*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)",
		"BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)",
		"*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "BIT    $S,($R$PLUS)", "*BIT   $S,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)",
		"*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)", "*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)", "RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)", "*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)",
		"*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)", "RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)", "*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)", "*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)",
		"RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)", "*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)", "*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)", "RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)",
		"*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)", "*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)", "*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)", "RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)",
		"*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)", "*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)", "RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)", "*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)",
		"*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)", "RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*RES   $S,B,($R$PLUS)", "*RES   $S,C,($R$PLUS)", "*RES   $S,D,($R$PLUS)", "*RES   $S,E,($R$PLUS)", "*RES   $S,H,($R$PLUS)", "*RES   $S,L,($R$PLUS)",
		"RES    $S,($R$PLUS)", "*RES   $S,A,($R$PLUS)", "*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)", "*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)",
		"*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)", "*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)", "*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)",
		"*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)", "*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)", "*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)",
		"*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)", "*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)", "*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)",
		"SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)", "*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)", "*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)",
		"*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)", "*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)", "*SET   $S,B,($R$PLUS)", "*SET   $S,C,($R$PLUS)",
		"*SET   $S,D,($R$PLUS)", "*SET   $S,E,($R$PLUS)", "*SET   $S,H,($R$PLUS)", "*SET   $S,L,($R$PLUS)", "SET    $S,($R$PLUS)", "*SET   $S,A,($R$PLUS)"
	};

	private byte[] log_f;

	private byte[] sbcf;

	private byte[] cpf;

	private byte[] cpf8b;

	private byte[] adcf;

	private byte[] rlcaf;

	private byte[] rrcaf;

	private static byte[] rlcf = new byte[256]
	{
		68, 0, 0, 4, 8, 12, 12, 8, 0, 4,
		4, 0, 12, 8, 8, 12, 32, 36, 36, 32,
		44, 40, 40, 44, 36, 32, 32, 36, 40, 44,
		44, 40, 0, 4, 4, 0, 12, 8, 8, 12,
		4, 0, 0, 4, 8, 12, 12, 8, 36, 32,
		32, 36, 40, 44, 44, 40, 32, 36, 36, 32,
		44, 40, 40, 44, 128, 132, 132, 128, 140, 136,
		136, 140, 132, 128, 128, 132, 136, 140, 140, 136,
		164, 160, 160, 164, 168, 172, 172, 168, 160, 164,
		164, 160, 172, 168, 168, 172, 132, 128, 128, 132,
		136, 140, 140, 136, 128, 132, 132, 128, 140, 136,
		136, 140, 160, 164, 164, 160, 172, 168, 168, 172,
		164, 160, 160, 164, 168, 172, 172, 168, 1, 5,
		5, 1, 13, 9, 9, 13, 5, 1, 1, 5,
		9, 13, 13, 9, 37, 33, 33, 37, 41, 45,
		45, 41, 33, 37, 37, 33, 45, 41, 41, 45,
		5, 1, 1, 5, 9, 13, 13, 9, 1, 5,
		5, 1, 13, 9, 9, 13, 33, 37, 37, 33,
		45, 41, 41, 45, 37, 33, 33, 37, 41, 45,
		45, 41, 133, 129, 129, 133, 137, 141, 141, 137,
		129, 133, 133, 129, 141, 137, 137, 141, 161, 165,
		165, 161, 173, 169, 169, 173, 165, 161, 161, 165,
		169, 173, 173, 169, 129, 133, 133, 129, 141, 137,
		137, 141, 133, 129, 129, 133, 137, 141, 141, 137,
		165, 161, 161, 165, 169, 173, 173, 169, 161, 165,
		165, 161, 173, 169, 169, 173
	};

	private static byte[] rrcf = new byte[256]
	{
		68, 129, 0, 133, 0, 133, 4, 129, 0, 133,
		4, 129, 4, 129, 0, 133, 8, 141, 12, 137,
		12, 137, 8, 141, 12, 137, 8, 141, 8, 141,
		12, 137, 0, 133, 4, 129, 4, 129, 0, 133,
		4, 129, 0, 133, 0, 133, 4, 129, 12, 137,
		8, 141, 8, 141, 12, 137, 8, 141, 12, 137,
		12, 137, 8, 141, 32, 165, 36, 161, 36, 161,
		32, 165, 36, 161, 32, 165, 32, 165, 36, 161,
		44, 169, 40, 173, 40, 173, 44, 169, 40, 173,
		44, 169, 44, 169, 40, 173, 36, 161, 32, 165,
		32, 165, 36, 161, 32, 165, 36, 161, 36, 161,
		32, 165, 40, 173, 44, 169, 44, 169, 40, 173,
		44, 169, 40, 173, 40, 173, 44, 169, 0, 133,
		4, 129, 4, 129, 0, 133, 4, 129, 0, 133,
		0, 133, 4, 129, 12, 137, 8, 141, 8, 141,
		12, 137, 8, 141, 12, 137, 12, 137, 8, 141,
		4, 129, 0, 133, 0, 133, 4, 129, 0, 133,
		4, 129, 4, 129, 0, 133, 8, 141, 12, 137,
		12, 137, 8, 141, 12, 137, 8, 141, 8, 141,
		12, 137, 36, 161, 32, 165, 32, 165, 36, 161,
		32, 165, 36, 161, 36, 161, 32, 165, 40, 173,
		44, 169, 44, 169, 40, 173, 44, 169, 40, 173,
		40, 173, 44, 169, 32, 165, 36, 161, 36, 161,
		32, 165, 36, 161, 32, 165, 32, 165, 36, 161,
		44, 169, 40, 173, 40, 173, 44, 169, 40, 173,
		44, 169, 44, 169, 40, 173
	};

	private static byte[] incf = new byte[256]
	{
		0, 0, 0, 0, 0, 0, 0, 8, 8, 8,
		8, 8, 8, 8, 8, 16, 0, 0, 0, 0,
		0, 0, 0, 8, 8, 8, 8, 8, 8, 8,
		8, 48, 32, 32, 32, 32, 32, 32, 32, 40,
		40, 40, 40, 40, 40, 40, 40, 48, 32, 32,
		32, 32, 32, 32, 32, 40, 40, 40, 40, 40,
		40, 40, 40, 16, 0, 0, 0, 0, 0, 0,
		0, 8, 8, 8, 8, 8, 8, 8, 8, 16,
		0, 0, 0, 0, 0, 0, 0, 8, 8, 8,
		8, 8, 8, 8, 8, 48, 32, 32, 32, 32,
		32, 32, 32, 40, 40, 40, 40, 40, 40, 40,
		40, 48, 32, 32, 32, 32, 32, 32, 32, 40,
		40, 40, 40, 40, 40, 40, 40, 148, 128, 128,
		128, 128, 128, 128, 128, 136, 136, 136, 136, 136,
		136, 136, 136, 144, 128, 128, 128, 128, 128, 128,
		128, 136, 136, 136, 136, 136, 136, 136, 136, 176,
		160, 160, 160, 160, 160, 160, 160, 168, 168, 168,
		168, 168, 168, 168, 168, 176, 160, 160, 160, 160,
		160, 160, 160, 168, 168, 168, 168, 168, 168, 168,
		168, 144, 128, 128, 128, 128, 128, 128, 128, 136,
		136, 136, 136, 136, 136, 136, 136, 144, 128, 128,
		128, 128, 128, 128, 128, 136, 136, 136, 136, 136,
		136, 136, 136, 176, 160, 160, 160, 160, 160, 160,
		160, 168, 168, 168, 168, 168, 168, 168, 168, 176,
		160, 160, 160, 160, 160, 160, 160, 168, 168, 168,
		168, 168, 168, 168, 168, 80
	};

	private static byte[] decf = new byte[256]
	{
		186, 66, 2, 2, 2, 2, 2, 2, 2, 10,
		10, 10, 10, 10, 10, 10, 26, 2, 2, 2,
		2, 2, 2, 2, 2, 10, 10, 10, 10, 10,
		10, 10, 26, 34, 34, 34, 34, 34, 34, 34,
		34, 42, 42, 42, 42, 42, 42, 42, 58, 34,
		34, 34, 34, 34, 34, 34, 34, 42, 42, 42,
		42, 42, 42, 42, 58, 2, 2, 2, 2, 2,
		2, 2, 2, 10, 10, 10, 10, 10, 10, 10,
		26, 2, 2, 2, 2, 2, 2, 2, 2, 10,
		10, 10, 10, 10, 10, 10, 26, 34, 34, 34,
		34, 34, 34, 34, 34, 42, 42, 42, 42, 42,
		42, 42, 58, 34, 34, 34, 34, 34, 34, 34,
		34, 42, 42, 42, 42, 42, 42, 42, 62, 130,
		130, 130, 130, 130, 130, 130, 130, 138, 138, 138,
		138, 138, 138, 138, 154, 130, 130, 130, 130, 130,
		130, 130, 130, 138, 138, 138, 138, 138, 138, 138,
		154, 162, 162, 162, 162, 162, 162, 162, 162, 170,
		170, 170, 170, 170, 170, 170, 186, 162, 162, 162,
		162, 162, 162, 162, 162, 170, 170, 170, 170, 170,
		170, 170, 186, 130, 130, 130, 130, 130, 130, 130,
		130, 138, 138, 138, 138, 138, 138, 138, 154, 130,
		130, 130, 130, 130, 130, 130, 130, 138, 138, 138,
		138, 138, 138, 138, 154, 162, 162, 162, 162, 162,
		162, 162, 162, 170, 170, 170, 170, 170, 170, 170,
		186, 162, 162, 162, 162, 162, 162, 162, 162, 170,
		170, 170, 170, 170, 170, 170
	};

	private static ushort[] daatab = new ushort[2048]
	{
		68, 256, 512, 772, 1024, 1284, 1540, 1792, 2056, 2316,
		4112, 4372, 4628, 4880, 5140, 5392, 4096, 4356, 4612, 4864,
		5124, 5376, 5632, 5892, 6156, 6408, 8240, 8500, 8756, 9008,
		9268, 9520, 8224, 8484, 8740, 8992, 9252, 9504, 9760, 10020,
		10284, 10536, 12340, 12592, 12848, 13108, 13360, 13620, 12324, 12576,
		12832, 13092, 13344, 13604, 13860, 14112, 14376, 14636, 16400, 16660,
		16916, 17168, 17428, 17680, 16384, 16644, 16900, 17152, 17412, 17664,
		17920, 18180, 18444, 18696, 20500, 20752, 21008, 21268, 21520, 21780,
		20484, 20736, 20992, 21252, 21504, 21764, 22020, 22272, 22536, 22796,
		24628, 24880, 25136, 25396, 25648, 25908, 24612, 24864, 25120, 25380,
		25632, 25892, 26148, 26400, 26664, 26924, 28720, 28980, 29236, 29488,
		29748, 30000, 28704, 28964, 29220, 29472, 29732, 29984, 30240, 30500,
		30764, 31016, 32912, 33172, 33428, 33680, 33940, 34192, 32896, 33156,
		33412, 33664, 33924, 34176, 34432, 34692, 34956, 35208, 37012, 37264,
		37520, 37780, 38032, 38292, 36996, 37248, 37504, 37764, 38016, 38276,
		38532, 38784, 39048, 39308, 85, 273, 529, 789, 1041, 1301,
		69, 257, 513, 773, 1025, 1285, 1541, 1793, 2057, 2317,
		4113, 4373, 4629, 4881, 5141, 5393, 4097, 4357, 4613, 4865,
		5125, 5377, 5633, 5893, 6157, 6409, 8241, 8501, 8757, 9009,
		9269, 9521, 8225, 8485, 8741, 8993, 9253, 9505, 9761, 10021,
		10285, 10537, 12341, 12593, 12849, 13109, 13361, 13621, 12325, 12577,
		12833, 13093, 13345, 13605, 13861, 14113, 14377, 14637, 16401, 16661,
		16917, 17169, 17429, 17681, 16385, 16645, 16901, 17153, 17413, 17665,
		17921, 18181, 18445, 18697, 20501, 20753, 21009, 21269, 21521, 21781,
		20485, 20737, 20993, 21253, 21505, 21765, 22021, 22273, 22537, 22797,
		24629, 24881, 25137, 25397, 25649, 25909, 24613, 24865, 25121, 25381,
		25633, 25893, 26149, 26401, 26665, 26925, 28721, 28981, 29237, 29489,
		29749, 30001, 28705, 28965, 29221, 29473, 29733, 29985, 30241, 30501,
		30765, 31017, 32913, 33173, 33429, 33681, 33941, 34193, 32897, 33157,
		33413, 33665, 33925, 34177, 34433, 34693, 34957, 35209, 37013, 37265,
		37521, 37781, 38033, 38293, 36997, 37249, 37505, 37765, 38017, 38277,
		38533, 38785, 39049, 39309, 41141, 41393, 41649, 41909, 42161, 42421,
		41125, 41377, 41633, 41893, 42145, 42405, 42661, 42913, 43177, 43437,
		45233, 45493, 45749, 46001, 46261, 46513, 45217, 45477, 45733, 45985,
		46245, 46497, 46753, 47013, 47277, 47529, 49301, 49553, 49809, 50069,
		50321, 50581, 49285, 49537, 49793, 50053, 50305, 50565, 50821, 51073,
		51337, 51597, 53393, 53653, 53909, 54161, 54421, 54673, 53377, 53637,
		53893, 54145, 54405, 54657, 54913, 55173, 55437, 55689, 57521, 57781,
		58037, 58289, 58549, 58801, 57505, 57765, 58021, 58273, 58533, 58785,
		59041, 59301, 59565, 59817, 61621, 61873, 62129, 62389, 62641, 62901,
		61605, 61857, 62113, 62373, 62625, 62885, 63141, 63393, 63657, 63917,
		85, 273, 529, 789, 1041, 1301, 69, 257, 513, 773,
		1025, 1285, 1541, 1793, 2057, 2317, 4113, 4373, 4629, 4881,
		5141, 5393, 4097, 4357, 4613, 4865, 5125, 5377, 5633, 5893,
		6157, 6409, 8241, 8501, 8757, 9009, 9269, 9521, 8225, 8485,
		8741, 8993, 9253, 9505, 9761, 10021, 10285, 10537, 12341, 12593,
		12849, 13109, 13361, 13621, 12325, 12577, 12833, 13093, 13345, 13605,
		13861, 14113, 14377, 14637, 16401, 16661, 16917, 17169, 17429, 17681,
		16385, 16645, 16901, 17153, 17413, 17665, 17921, 18181, 18445, 18697,
		20501, 20753, 21009, 21269, 21521, 21781, 20485, 20737, 20993, 21253,
		21505, 21765, 22021, 22273, 22537, 22797, 24629, 24881, 25137, 25397,
		25649, 25909, 70, 258, 514, 774, 1026, 1286, 1542, 1794,
		2058, 2318, 1026, 1286, 1542, 1794, 2058, 2318, 4098, 4358,
		4614, 4866, 5126, 5378, 5634, 5894, 6158, 6410, 5126, 5378,
		5634, 5894, 6158, 6410, 8226, 8486, 8742, 8994, 9254, 9506,
		9762, 10022, 10286, 10538, 9254, 9506, 9762, 10022, 10286, 10538,
		12326, 12578, 12834, 13094, 13346, 13606, 13862, 14114, 14378, 14638,
		13346, 13606, 13862, 14114, 14378, 14638, 16386, 16646, 16902, 17154,
		17414, 17666, 17922, 18182, 18446, 18698, 17414, 17666, 17922, 18182,
		18446, 18698, 20486, 20738, 20994, 21254, 21506, 21766, 22022, 22274,
		22538, 22798, 21506, 21766, 22022, 22274, 22538, 22798, 24614, 24866,
		25122, 25382, 25634, 25894, 26150, 26402, 26666, 26926, 25634, 25894,
		26150, 26402, 26666, 26926, 28706, 28966, 29222, 29474, 29734, 29986,
		30242, 30502, 30766, 31018, 29734, 29986, 30242, 30502, 30766, 31018,
		32898, 33158, 33414, 33666, 33926, 34178, 34434, 34694, 34958, 35210,
		33926, 34178, 34434, 34694, 34958, 35210, 36998, 37250, 37506, 37766,
		38018, 38278, 38534, 38786, 39050, 39310, 13347, 13607, 13863, 14115,
		14379, 14639, 16387, 16647, 16903, 17155, 17415, 17667, 17923, 18183,
		18447, 18699, 17415, 17667, 17923, 18183, 18447, 18699, 20487, 20739,
		20995, 21255, 21507, 21767, 22023, 22275, 22539, 22799, 21507, 21767,
		22023, 22275, 22539, 22799, 24615, 24867, 25123, 25383, 25635, 25895,
		26151, 26403, 26667, 26927, 25635, 25895, 26151, 26403, 26667, 26927,
		28707, 28967, 29223, 29475, 29735, 29987, 30243, 30503, 30767, 31019,
		29735, 29987, 30243, 30503, 30767, 31019, 32899, 33159, 33415, 33667,
		33927, 34179, 34435, 34695, 34959, 35211, 33927, 34179, 34435, 34695,
		34959, 35211, 36999, 37251, 37507, 37767, 38019, 38279, 38535, 38787,
		39051, 39311, 38019, 38279, 38535, 38787, 39051, 39311, 41127, 41379,
		41635, 41895, 42147, 42407, 42663, 42915, 43179, 43439, 42147, 42407,
		42663, 42915, 43179, 43439, 45219, 45479, 45735, 45987, 46247, 46499,
		46755, 47015, 47279, 47531, 46247, 46499, 46755, 47015, 47279, 47531,
		49287, 49539, 49795, 50055, 50307, 50567, 50823, 51075, 51339, 51599,
		50307, 50567, 50823, 51075, 51339, 51599, 53379, 53639, 53895, 54147,
		54407, 54659, 54915, 55175, 55439, 55691, 54407, 54659, 54915, 55175,
		55439, 55691, 57507, 57767, 58023, 58275, 58535, 58787, 59043, 59303,
		59567, 59819, 58535, 58787, 59043, 59303, 59567, 59819, 61607, 61859,
		62115, 62375, 62627, 62887, 63143, 63395, 63659, 63919, 62627, 62887,
		63143, 63395, 63659, 63919, 71, 259, 515, 775, 1027, 1287,
		1543, 1795, 2059, 2319, 1027, 1287, 1543, 1795, 2059, 2319,
		4099, 4359, 4615, 4867, 5127, 5379, 5635, 5895, 6159, 6411,
		5127, 5379, 5635, 5895, 6159, 6411, 8227, 8487, 8743, 8995,
		9255, 9507, 9763, 10023, 10287, 10539, 9255, 9507, 9763, 10023,
		10287, 10539, 12327, 12579, 12835, 13095, 13347, 13607, 13863, 14115,
		14379, 14639, 13347, 13607, 13863, 14115, 14379, 14639, 16387, 16647,
		16903, 17155, 17415, 17667, 17923, 18183, 18447, 18699, 17415, 17667,
		17923, 18183, 18447, 18699, 20487, 20739, 20995, 21255, 21507, 21767,
		22023, 22275, 22539, 22799, 21507, 21767, 22023, 22275, 22539, 22799,
		24615, 24867, 25123, 25383, 25635, 25895, 26151, 26403, 26667, 26927,
		25635, 25895, 26151, 26403, 26667, 26927, 28707, 28967, 29223, 29475,
		29735, 29987, 30243, 30503, 30767, 31019, 29735, 29987, 30243, 30503,
		30767, 31019, 32899, 33159, 33415, 33667, 33927, 34179, 34435, 34695,
		34959, 35211, 33927, 34179, 34435, 34695, 34959, 35211, 36999, 37251,
		37507, 37767, 38019, 38279, 38535, 38787, 39051, 39311, 38019, 38279,
		38535, 38787, 39051, 39311, 1540, 1792, 2056, 2316, 2572, 2824,
		3084, 3336, 3592, 3852, 4112, 4372, 4628, 4880, 5140, 5392,
		5632, 5892, 6156, 6408, 6664, 6924, 7176, 7436, 7692, 7944,
		8240, 8500, 8756, 9008, 9268, 9520, 9760, 10020, 10284, 10536,
		10792, 11052, 11304, 11564, 11820, 12072, 12340, 12592, 12848, 13108,
		13360, 13620, 13860, 14112, 14376, 14636, 14892, 15144, 15404, 15656,
		15912, 16172, 16400, 16660, 16916, 17168, 17428, 17680, 17920, 18180,
		18444, 18696, 18952, 19212, 19464, 19724, 19980, 20232, 20500, 20752,
		21008, 21268, 21520, 21780, 22020, 22272, 22536, 22796, 23052, 23304,
		23564, 23816, 24072, 24332, 24628, 24880, 25136, 25396, 25648, 25908,
		26148, 26400, 26664, 26924, 27180, 27432, 27692, 27944, 28200, 28460,
		28720, 28980, 29236, 29488, 29748, 30000, 30240, 30500, 30764, 31016,
		31272, 31532, 31784, 32044, 32300, 32552, 32912, 33172, 33428, 33680,
		33940, 34192, 34432, 34692, 34956, 35208, 35464, 35724, 35976, 36236,
		36492, 36744, 37012, 37264, 37520, 37780, 38032, 38292, 38532, 38784,
		39048, 39308, 39564, 39816, 40076, 40328, 40584, 40844, 85, 273,
		529, 789, 1041, 1301, 1541, 1793, 2057, 2317, 2573, 2825,
		3085, 3337, 3593, 3853, 4113, 4373, 4629, 4881, 5141, 5393,
		5633, 5893, 6157, 6409, 6665, 6925, 7177, 7437, 7693, 7945,
		8241, 8501, 8757, 9009, 9269, 9521, 9761, 10021, 10285, 10537,
		10793, 11053, 11305, 11565, 11821, 12073, 12341, 12593, 12849, 13109,
		13361, 13621, 13861, 14113, 14377, 14637, 14893, 15145, 15405, 15657,
		15913, 16173, 16401, 16661, 16917, 17169, 17429, 17681, 17921, 18181,
		18445, 18697, 18953, 19213, 19465, 19725, 19981, 20233, 20501, 20753,
		21009, 21269, 21521, 21781, 22021, 22273, 22537, 22797, 23053, 23305,
		23565, 23817, 24073, 24333, 24629, 24881, 25137, 25397, 25649, 25909,
		26149, 26401, 26665, 26925, 27181, 27433, 27693, 27945, 28201, 28461,
		28721, 28981, 29237, 29489, 29749, 30001, 30241, 30501, 30765, 31017,
		31273, 31533, 31785, 32045, 32301, 32553, 32913, 33173, 33429, 33681,
		33941, 34193, 34433, 34693, 34957, 35209, 35465, 35725, 35977, 36237,
		36493, 36745, 37013, 37265, 37521, 37781, 38033, 38293, 38533, 38785,
		39049, 39309, 39565, 39817, 40077, 40329, 40585, 40845, 41141, 41393,
		41649, 41909, 42161, 42421, 42661, 42913, 43177, 43437, 43693, 43945,
		44205, 44457, 44713, 44973, 45233, 45493, 45749, 46001, 46261, 46513,
		46753, 47013, 47277, 47529, 47785, 48045, 48297, 48557, 48813, 49065,
		49301, 49553, 49809, 50069, 50321, 50581, 50821, 51073, 51337, 51597,
		51853, 52105, 52365, 52617, 52873, 53133, 53393, 53653, 53909, 54161,
		54421, 54673, 54913, 55173, 55437, 55689, 55945, 56205, 56457, 56717,
		56973, 57225, 57521, 57781, 58037, 58289, 58549, 58801, 59041, 59301,
		59565, 59817, 60073, 60333, 60585, 60845, 61101, 61353, 61621, 61873,
		62129, 62389, 62641, 62901, 63141, 63393, 63657, 63917, 64173, 64425,
		64685, 64937, 65193, 65453, 85, 273, 529, 789, 1041, 1301,
		1541, 1793, 2057, 2317, 2573, 2825, 3085, 3337, 3593, 3853,
		4113, 4373, 4629, 4881, 5141, 5393, 5633, 5893, 6157, 6409,
		6665, 6925, 7177, 7437, 7693, 7945, 8241, 8501, 8757, 9009,
		9269, 9521, 9761, 10021, 10285, 10537, 10793, 11053, 11305, 11565,
		11821, 12073, 12341, 12593, 12849, 13109, 13361, 13621, 13861, 14113,
		14377, 14637, 14893, 15145, 15405, 15657, 15913, 16173, 16401, 16661,
		16917, 17169, 17429, 17681, 17921, 18181, 18445, 18697, 18953, 19213,
		19465, 19725, 19981, 20233, 20501, 20753, 21009, 21269, 21521, 21781,
		22021, 22273, 22537, 22797, 23053, 23305, 23565, 23817, 24073, 24333,
		24629, 24881, 25137, 25397, 25649, 25909, 64190, 64442, 64702, 64954,
		65210, 65470, 70, 258, 514, 774, 1026, 1286, 1542, 1794,
		2058, 2318, 2590, 2842, 3102, 3354, 3610, 3870, 4098, 4358,
		4614, 4866, 5126, 5378, 5634, 5894, 6158, 6410, 6682, 6942,
		7194, 7454, 7710, 7962, 8226, 8486, 8742, 8994, 9254, 9506,
		9762, 10022, 10286, 10538, 10810, 11070, 11322, 11582, 11838, 12090,
		12326, 12578, 12834, 13094, 13346, 13606, 13862, 14114, 14378, 14638,
		14910, 15162, 15422, 15674, 15930, 16190, 16386, 16646, 16902, 17154,
		17414, 17666, 17922, 18182, 18446, 18698, 18970, 19230, 19482, 19742,
		19998, 20250, 20486, 20738, 20994, 21254, 21506, 21766, 22022, 22274,
		22538, 22798, 23070, 23322, 23582, 23834, 24090, 24350, 24614, 24866,
		25122, 25382, 25634, 25894, 26150, 26402, 26666, 26926, 27198, 27450,
		27710, 27962, 28218, 28478, 28706, 28966, 29222, 29474, 29734, 29986,
		30242, 30502, 30766, 31018, 31290, 31550, 31802, 32062, 32318, 32570,
		32898, 33158, 33414, 33666, 33926, 34178, 34434, 34694, 34958, 35210,
		35482, 35742, 35994, 36254, 36510, 36762, 36998, 37250, 37506, 37766,
		13347, 13607, 13863, 14115, 14379, 14639, 14911, 15163, 15423, 15675,
		15931, 16191, 16387, 16647, 16903, 17155, 17415, 17667, 17923, 18183,
		18447, 18699, 18971, 19231, 19483, 19743, 19999, 20251, 20487, 20739,
		20995, 21255, 21507, 21767, 22023, 22275, 22539, 22799, 23071, 23323,
		23583, 23835, 24091, 24351, 24615, 24867, 25123, 25383, 25635, 25895,
		26151, 26403, 26667, 26927, 27199, 27451, 27711, 27963, 28219, 28479,
		28707, 28967, 29223, 29475, 29735, 29987, 30243, 30503, 30767, 31019,
		31291, 31551, 31803, 32063, 32319, 32571, 32899, 33159, 33415, 33667,
		33927, 34179, 34435, 34695, 34959, 35211, 35483, 35743, 35995, 36255,
		36511, 36763, 36999, 37251, 37507, 37767, 38019, 38279, 38535, 38787,
		39051, 39311, 39583, 39835, 40095, 40347, 40603, 40863, 41127, 41379,
		41635, 41895, 42147, 42407, 42663, 42915, 43179, 43439, 43711, 43963,
		44223, 44475, 44731, 44991, 45219, 45479, 45735, 45987, 46247, 46499,
		46755, 47015, 47279, 47531, 47803, 48063, 48315, 48575, 48831, 49083,
		49287, 49539, 49795, 50055, 50307, 50567, 50823, 51075, 51339, 51599,
		51871, 52123, 52383, 52635, 52891, 53151, 53379, 53639, 53895, 54147,
		54407, 54659, 54915, 55175, 55439, 55691, 55963, 56223, 56475, 56735,
		56991, 57243, 57507, 57767, 58023, 58275, 58535, 58787, 59043, 59303,
		59567, 59819, 60091, 60351, 60603, 60863, 61119, 61371, 61607, 61859,
		62115, 62375, 62627, 62887, 63143, 63395, 63659, 63919, 64191, 64443,
		64703, 64955, 65211, 65471, 71, 259, 515, 775, 1027, 1287,
		1543, 1795, 2059, 2319, 2591, 2843, 3103, 3355, 3611, 3871,
		4099, 4359, 4615, 4867, 5127, 5379, 5635, 5895, 6159, 6411,
		6683, 6943, 7195, 7455, 7711, 7963, 8227, 8487, 8743, 8995,
		9255, 9507, 9763, 10023, 10287, 10539, 10811, 11071, 11323, 11583,
		11839, 12091, 12327, 12579, 12835, 13095, 13347, 13607, 13863, 14115,
		14379, 14639, 14911, 15163, 15423, 15675, 15931, 16191, 16387, 16647,
		16903, 17155, 17415, 17667, 17923, 18183, 18447, 18699, 18971, 19231,
		19483, 19743, 19999, 20251, 20487, 20739, 20995, 21255, 21507, 21767,
		22023, 22275, 22539, 22799, 23071, 23323, 23583, 23835, 24091, 24351,
		24615, 24867, 25123, 25383, 25635, 25895, 26151, 26403, 26667, 26927,
		27199, 27451, 27711, 27963, 28219, 28479, 28707, 28967, 29223, 29475,
		29735, 29987, 30243, 30503, 30767, 31019, 31291, 31551, 31803, 32063,
		32319, 32571, 32899, 33159, 33415, 33667, 33927, 34179, 34435, 34695,
		34959, 35211, 35483, 35743, 35995, 36255, 36511, 36763, 36999, 37251,
		37507, 37767, 38019, 38279, 38535, 38787, 39051, 39311
	};

	private static byte[] rl0 = new byte[256]
	{
		68, 0, 0, 4, 8, 12, 12, 8, 0, 4,
		4, 0, 12, 8, 8, 12, 32, 36, 36, 32,
		44, 40, 40, 44, 36, 32, 32, 36, 40, 44,
		44, 40, 0, 4, 4, 0, 12, 8, 8, 12,
		4, 0, 0, 4, 8, 12, 12, 8, 36, 32,
		32, 36, 40, 44, 44, 40, 32, 36, 36, 32,
		44, 40, 40, 44, 128, 132, 132, 128, 140, 136,
		136, 140, 132, 128, 128, 132, 136, 140, 140, 136,
		164, 160, 160, 164, 168, 172, 172, 168, 160, 164,
		164, 160, 172, 168, 168, 172, 132, 128, 128, 132,
		136, 140, 140, 136, 128, 132, 132, 128, 140, 136,
		136, 140, 160, 164, 164, 160, 172, 168, 168, 172,
		164, 160, 160, 164, 168, 172, 172, 168, 69, 1,
		1, 5, 9, 13, 13, 9, 1, 5, 5, 1,
		13, 9, 9, 13, 33, 37, 37, 33, 45, 41,
		41, 45, 37, 33, 33, 37, 41, 45, 45, 41,
		1, 5, 5, 1, 13, 9, 9, 13, 5, 1,
		1, 5, 9, 13, 13, 9, 37, 33, 33, 37,
		41, 45, 45, 41, 33, 37, 37, 33, 45, 41,
		41, 45, 129, 133, 133, 129, 141, 137, 137, 141,
		133, 129, 129, 133, 137, 141, 141, 137, 165, 161,
		161, 165, 169, 173, 173, 169, 161, 165, 165, 161,
		173, 169, 169, 173, 133, 129, 129, 133, 137, 141,
		141, 137, 129, 133, 133, 129, 141, 137, 137, 141,
		161, 165, 165, 161, 173, 169, 169, 173, 165, 161,
		161, 165, 169, 173, 173, 169
	};

	private static byte[] rl1 = new byte[256]
	{
		0, 4, 4, 0, 12, 8, 8, 12, 4, 0,
		0, 4, 8, 12, 12, 8, 36, 32, 32, 36,
		40, 44, 44, 40, 32, 36, 36, 32, 44, 40,
		40, 44, 4, 0, 0, 4, 8, 12, 12, 8,
		0, 4, 4, 0, 12, 8, 8, 12, 32, 36,
		36, 32, 44, 40, 40, 44, 36, 32, 32, 36,
		40, 44, 44, 40, 132, 128, 128, 132, 136, 140,
		140, 136, 128, 132, 132, 128, 140, 136, 136, 140,
		160, 164, 164, 160, 172, 168, 168, 172, 164, 160,
		160, 164, 168, 172, 172, 168, 128, 132, 132, 128,
		140, 136, 136, 140, 132, 128, 128, 132, 136, 140,
		140, 136, 164, 160, 160, 164, 168, 172, 172, 168,
		160, 164, 164, 160, 172, 168, 168, 172, 1, 5,
		5, 1, 13, 9, 9, 13, 5, 1, 1, 5,
		9, 13, 13, 9, 37, 33, 33, 37, 41, 45,
		45, 41, 33, 37, 37, 33, 45, 41, 41, 45,
		5, 1, 1, 5, 9, 13, 13, 9, 1, 5,
		5, 1, 13, 9, 9, 13, 33, 37, 37, 33,
		45, 41, 41, 45, 37, 33, 33, 37, 41, 45,
		45, 41, 133, 129, 129, 133, 137, 141, 141, 137,
		129, 133, 133, 129, 141, 137, 137, 141, 161, 165,
		165, 161, 173, 169, 169, 173, 165, 161, 161, 165,
		169, 173, 173, 169, 129, 133, 133, 129, 141, 137,
		137, 141, 133, 129, 129, 133, 137, 141, 141, 137,
		165, 161, 161, 165, 169, 173, 173, 169, 161, 165,
		165, 161, 173, 169, 169, 173
	};

	private static byte[] rr0 = new byte[256]
	{
		68, 69, 0, 1, 0, 1, 4, 5, 0, 1,
		4, 5, 4, 5, 0, 1, 8, 9, 12, 13,
		12, 13, 8, 9, 12, 13, 8, 9, 8, 9,
		12, 13, 0, 1, 4, 5, 4, 5, 0, 1,
		4, 5, 0, 1, 0, 1, 4, 5, 12, 13,
		8, 9, 8, 9, 12, 13, 8, 9, 12, 13,
		12, 13, 8, 9, 32, 33, 36, 37, 36, 37,
		32, 33, 36, 37, 32, 33, 32, 33, 36, 37,
		44, 45, 40, 41, 40, 41, 44, 45, 40, 41,
		44, 45, 44, 45, 40, 41, 36, 37, 32, 33,
		32, 33, 36, 37, 32, 33, 36, 37, 36, 37,
		32, 33, 40, 41, 44, 45, 44, 45, 40, 41,
		44, 45, 40, 41, 40, 41, 44, 45, 0, 1,
		4, 5, 4, 5, 0, 1, 4, 5, 0, 1,
		0, 1, 4, 5, 12, 13, 8, 9, 8, 9,
		12, 13, 8, 9, 12, 13, 12, 13, 8, 9,
		4, 5, 0, 1, 0, 1, 4, 5, 0, 1,
		4, 5, 4, 5, 0, 1, 8, 9, 12, 13,
		12, 13, 8, 9, 12, 13, 8, 9, 8, 9,
		12, 13, 36, 37, 32, 33, 32, 33, 36, 37,
		32, 33, 36, 37, 36, 37, 32, 33, 40, 41,
		44, 45, 44, 45, 40, 41, 44, 45, 40, 41,
		40, 41, 44, 45, 32, 33, 36, 37, 36, 37,
		32, 33, 36, 37, 32, 33, 32, 33, 36, 37,
		44, 45, 40, 41, 40, 41, 44, 45, 40, 41,
		44, 45, 44, 45, 40, 41
	};

	private static byte[] rr1 = new byte[256]
	{
		128, 129, 132, 133, 132, 133, 128, 129, 132, 133,
		128, 129, 128, 129, 132, 133, 140, 141, 136, 137,
		136, 137, 140, 141, 136, 137, 140, 141, 140, 141,
		136, 137, 132, 133, 128, 129, 128, 129, 132, 133,
		128, 129, 132, 133, 132, 133, 128, 129, 136, 137,
		140, 141, 140, 141, 136, 137, 140, 141, 136, 137,
		136, 137, 140, 141, 164, 165, 160, 161, 160, 161,
		164, 165, 160, 161, 164, 165, 164, 165, 160, 161,
		168, 169, 172, 173, 172, 173, 168, 169, 172, 173,
		168, 169, 168, 169, 172, 173, 160, 161, 164, 165,
		164, 165, 160, 161, 164, 165, 160, 161, 160, 161,
		164, 165, 172, 173, 168, 169, 168, 169, 172, 173,
		168, 169, 172, 173, 172, 173, 168, 169, 132, 133,
		128, 129, 128, 129, 132, 133, 128, 129, 132, 133,
		132, 133, 128, 129, 136, 137, 140, 141, 140, 141,
		136, 137, 140, 141, 136, 137, 136, 137, 140, 141,
		128, 129, 132, 133, 132, 133, 128, 129, 132, 133,
		128, 129, 128, 129, 132, 133, 140, 141, 136, 137,
		136, 137, 140, 141, 136, 137, 140, 141, 140, 141,
		136, 137, 160, 161, 164, 165, 164, 165, 160, 161,
		164, 165, 160, 161, 160, 161, 164, 165, 172, 173,
		168, 169, 168, 169, 172, 173, 168, 169, 172, 173,
		172, 173, 168, 169, 164, 165, 160, 161, 160, 161,
		164, 165, 160, 161, 164, 165, 164, 165, 160, 161,
		168, 169, 172, 173, 172, 173, 168, 169, 172, 173,
		168, 169, 168, 169, 172, 173
	};

	private static byte[] sraf = new byte[256]
	{
		68, 69, 0, 1, 0, 1, 4, 5, 0, 1,
		4, 5, 4, 5, 0, 1, 8, 9, 12, 13,
		12, 13, 8, 9, 12, 13, 8, 9, 8, 9,
		12, 13, 0, 1, 4, 5, 4, 5, 0, 1,
		4, 5, 0, 1, 0, 1, 4, 5, 12, 13,
		8, 9, 8, 9, 12, 13, 8, 9, 12, 13,
		12, 13, 8, 9, 32, 33, 36, 37, 36, 37,
		32, 33, 36, 37, 32, 33, 32, 33, 36, 37,
		44, 45, 40, 41, 40, 41, 44, 45, 40, 41,
		44, 45, 44, 45, 40, 41, 36, 37, 32, 33,
		32, 33, 36, 37, 32, 33, 36, 37, 36, 37,
		32, 33, 40, 41, 44, 45, 44, 45, 40, 41,
		44, 45, 40, 41, 40, 41, 44, 45, 132, 133,
		128, 129, 128, 129, 132, 133, 128, 129, 132, 133,
		132, 133, 128, 129, 136, 137, 140, 141, 140, 141,
		136, 137, 140, 141, 136, 137, 136, 137, 140, 141,
		128, 129, 132, 133, 132, 133, 128, 129, 132, 133,
		128, 129, 128, 129, 132, 133, 140, 141, 136, 137,
		136, 137, 140, 141, 136, 137, 140, 141, 140, 141,
		136, 137, 160, 161, 164, 165, 164, 165, 160, 161,
		164, 165, 160, 161, 160, 161, 164, 165, 172, 173,
		168, 169, 168, 169, 172, 173, 168, 169, 172, 173,
		172, 173, 168, 169, 164, 165, 160, 161, 160, 161,
		164, 165, 160, 161, 164, 165, 164, 165, 160, 161,
		168, 169, 172, 173, 172, 173, 168, 169, 172, 173,
		168, 169, 168, 169, 172, 173
	};

	public Z80CPU()
	{
		ALU_INIT();
		initExecTBL();
	}

	public void Reset()
	{
		RST = true;
		ExecCycle();
		RST = false;
	}

	public void ExecCycle()
	{
		if (OnCycle != null)
		{
			OnCycle();
		}
		if (ParseSignals())
		{
			return;
		}
		if (!HALTED)
		{
			byte b = ReadMemory(regs.PC, M1: true);
			Tact += 3uL;
			regs.PC++;
			if (XFX == OPXFX.CB)
			{
				BlockINT = false;
				ExecCB(b);
				XFX = OPXFX.NONE;
				FX = OPFX.NONE;
				return;
			}
			if (XFX == OPXFX.ED)
			{
				RegenMemory();
				BlockINT = false;
				ExecED(b);
				XFX = OPXFX.NONE;
				FX = OPFX.NONE;
				return;
			}
			switch (b)
			{
			case 221:
				RegenMemory();
				FX = OPFX.IX;
				BlockINT = true;
				break;
			case 253:
				RegenMemory();
				FX = OPFX.IY;
				BlockINT = true;
				break;
			case 203:
				RegenMemory();
				XFX = OPXFX.CB;
				BlockINT = true;
				break;
			case 237:
				RegenMemory();
				XFX = OPXFX.ED;
				BlockINT = true;
				break;
			default:
				RegenMemory();
				BlockINT = false;
				ExecDirect(b);
				FX = OPFX.NONE;
				break;
			}
		}
		else
		{
			Tact += 3uL;
			RegenMemory();
		}
	}

	private void ExecED(byte cmd)
	{
		edopTABLE[cmd]?.Invoke(cmd);
	}

	private void ExecCB(byte cmd)
	{
		if (FX != 0)
		{
			if (FX == OPFX.IX)
			{
				regs.MW = (ushort)(regs.IX + (sbyte)cmd);
			}
			else
			{
				regs.MW = (ushort)(regs.IY + (sbyte)cmd);
			}
			Tact++;
			cmd = ReadMemory(regs.PC, M1: true);
			Tact += 3uL;
			regs.PC++;
			fxcbopTABLE[cmd](cmd, regs.MW);
		}
		else
		{
			cbopTABLE[cmd](cmd);
			RegenMemory();
		}
	}

	private void ExecDirect(byte cmd)
	{
		((FX != 0) ? fxopTABLE[cmd] : opTABLE[cmd])?.Invoke(cmd);
	}

	private void RegenMemory()
	{
		regs.R = (byte)(((uint)(regs.R + 1) & 0x7Fu) | (regs.R & 0x80u));
		Tact++;
	}

	private bool ParseSignals()
	{
		if (RST)
		{
			regs.PC = 0;
			regs.IR = 0;
			IFF1 = false;
			IFF2 = false;
			IM = 0;
			HALTED = false;
			FX = OPFX.NONE;
			XFX = OPXFX.NONE;
			Tact += 4uL;
			return true;
		}
		if (NMI)
		{
			IFF1 = false;
			HALTED = false;
			regs.SP--;
			Tact++;
			WriteMemory(regs.SP, (byte)(regs.PC >> 8));
			Tact += 3uL;
			regs.SP--;
			WriteMemory(regs.SP, (byte)(regs.PC & 0xFFu));
			Tact += 3uL;
			regs.PC = 102;
			return true;
		}
		if (INT && !BlockINT && IFF1)
		{
			IFF1 = false;
			IFF2 = false;
			HALTED = false;
			regs.SP--;
			Tact++;
			WriteMemory(regs.SP, (byte)(regs.PC >> 8));
			Tact += 3uL;
			regs.SP--;
			WriteMemory(regs.SP, (byte)(regs.PC & 0xFFu));
			Tact += 3uL;
			if (IM == 0)
			{
				regs.MW = 56;
				Tact += 5uL;
			}
			else if (IM == 1)
			{
				regs.MW = 56;
				Tact += 5uL;
			}
			else
			{
				ushort freeBUS = FreeBUS;
				freeBUS = (ushort)(freeBUS + (ushort)(regs.IR & 0xFF00));
				regs.MW = ReadMemory(freeBUS, M1: true);
				Tact += 3uL;
				regs.MW += (ushort)(ReadMemory(freeBUS = (ushort)(freeBUS + 1), M1: true) * 256);
				Tact += 3uL;
				Tact += 6uL;
			}
			regs.PC = regs.MW;
			return true;
		}
		return false;
	}

	private void initExecTBL()
	{
		initExec();
		initExecFX();
		initExecED();
		initExecCB();
	}

	private void ED_LDI(byte cmd)
	{
		byte b = ReadMemory(regs.HL++, M1: false);
		Tact += 4uL;
		WriteMemory(regs.DE++, b);
		Tact += 4uL;
		b = (byte)(b + regs.A);
		b = (byte)((b & 8) + ((b << 4) & 0x20));
		regs.F = (byte)((regs.F & 0xC1) + b);
		if (--regs.BC != 0)
		{
			regs.F |= 4;
		}
	}

	private void ED_CPI(byte cmd)
	{
		byte b = (byte)(regs.F & 1u);
		byte b2 = ReadMemory(regs.HL++, M1: false);
		Tact += 4uL;
		regs.F = (byte)(cpf8b[regs.A * 256 + b2] + b);
		Tact += 4uL;
		if (--regs.BC != 0)
		{
			regs.F |= 4;
		}
		regs.MW++;
	}

	private void ED_INI(byte cmd)
	{
		regs.MW = (ushort)(regs.BC + 1);
		byte value = ReadPort(regs.BC);
		Tact += 4uL;
		WriteMemory(regs.HL++, value);
		Tact += 3uL;
		regs.B = ALU_DECR(regs.B);
		Tact++;
	}

	private void ED_OUTI(byte cmd)
	{
		regs.B = ALU_DECR(regs.B);
		Tact++;
		byte value = ReadMemory(regs.HL++, M1: false);
		Tact += 3uL;
		WritePort(regs.BC, value);
		Tact += 4uL;
		regs.F &= 254;
		if (regs.L == 0)
		{
			regs.F |= 1;
		}
		regs.MW = (ushort)(regs.BC + 1);
	}

	private void ED_LDD(byte cmd)
	{
		byte b = ReadMemory(regs.HL--, M1: false);
		Tact += 3uL;
		WriteMemory(regs.DE--, b);
		Tact += 3uL;
		b = (byte)(b + regs.A);
		b = (byte)((b & 8) + ((b << 4) & 0x20));
		regs.F = (byte)((regs.F & 0xC1) + b);
		if (--regs.BC != 0)
		{
			regs.F |= 4;
		}
		Tact += 2uL;
	}

	private void ED_CPD(byte cmd)
	{
		byte b = (byte)(regs.F & 1u);
		byte b2 = ReadMemory(regs.HL--, M1: false);
		Tact += 4uL;
		regs.F = (byte)(cpf8b[regs.A * 256 + b2] + b);
		if (--regs.BC != 0)
		{
			regs.F |= 4;
		}
		Tact += 4uL;
		regs.MW--;
	}

	private void ED_IND(byte cmd)
	{
		regs.MW = (ushort)(regs.BC - 1);
		byte value = ReadPort(regs.BC);
		Tact += 4uL;
		WriteMemory(regs.HL--, value);
		Tact += 3uL;
		regs.B = ALU_DECR(regs.B);
		Tact++;
	}

	private void ED_OUTD(byte cmd)
	{
		regs.B = ALU_DECR(regs.B);
		Tact++;
		byte value = ReadMemory(regs.HL--, M1: false);
		Tact += 3uL;
		WritePort(regs.BC, value);
		Tact += 4uL;
		regs.F &= 254;
		if (regs.L == byte.MaxValue)
		{
			regs.F |= 1;
		}
		regs.MW = (ushort)(regs.BC - 1);
	}

	private void ED_LDIR(byte cmd)
	{
		byte b = ReadMemory(regs.HL++, M1: false);
		Tact += 3uL;
		WriteMemory(regs.DE++, b);
		Tact += 3uL;
		b = (byte)(b + regs.A);
		b = (byte)((b & 8) + ((b << 4) & 0x20));
		regs.F = (byte)((regs.F & 0xC1) + b);
		Tact += 2uL;
		if (--regs.BC != 0)
		{
			regs.F |= 4;
			regs.PC -= 2;
			Tact += 5uL;
			regs.MW = (ushort)(regs.PC + 1);
		}
	}

	private void ED_CPIR(byte cmd)
	{
		regs.MW++;
		byte b = (byte)(regs.F & 1u);
		byte b2 = ReadMemory(regs.HL++, M1: false);
		Tact += 3uL;
		regs.F = (byte)(cpf8b[regs.A * 256 + b2] + b);
		Tact += 5uL;
		if (--regs.BC != 0)
		{
			regs.F |= 4;
			if ((regs.F & 0x40) == 0)
			{
				regs.PC -= 2;
				Tact += 5uL;
				regs.MW = (ushort)(regs.PC + 1);
			}
		}
	}

	private void ED_INIR(byte cmd)
	{
		regs.MW = (ushort)(regs.BC + 1);
		byte value = ReadPort(regs.BC);
		Tact += 4uL;
		WriteMemory(regs.HL++, value);
		Tact += 4uL;
		regs.B = ALU_DECR(regs.B);
		if (regs.B != 0)
		{
			regs.F |= 4;
			regs.PC -= 2;
			Tact += 5uL;
		}
		else
		{
			regs.F &= 251;
		}
	}

	private void ED_OTIR(byte cmd)
	{
		regs.B = ALU_DECR(regs.B);
		byte value = ReadMemory(regs.HL++, M1: false);
		Tact += 4uL;
		WritePort(regs.BC, value);
		Tact += 4uL;
		if (regs.B != 0)
		{
			regs.F |= 4;
			regs.PC -= 2;
			Tact += 5uL;
		}
		else
		{
			regs.F &= 251;
		}
		regs.F &= 254;
		if (regs.L == 0)
		{
			regs.F |= 1;
		}
		regs.MW = (ushort)(regs.BC + 1);
	}

	private void ED_LDDR(byte cmd)
	{
		byte b = ReadMemory(regs.HL--, M1: false);
		Tact += 4uL;
		WriteMemory(regs.DE--, b);
		Tact += 4uL;
		b = (byte)(b + regs.A);
		b = (byte)((b & 8) + ((b << 4) & 0x20));
		regs.F = (byte)((regs.F & 0xC1) + b);
		if (--regs.BC != 0)
		{
			regs.F |= 4;
			regs.PC -= 2;
			Tact += 5uL;
		}
	}

	private void ED_CPDR(byte cmd)
	{
		regs.MW--;
		byte b = (byte)(regs.F & 1u);
		byte b2 = ReadMemory(regs.HL--, M1: false);
		Tact += 4uL;
		regs.F = (byte)(cpf8b[regs.A * 256 + b2] + b);
		Tact += 4uL;
		if (--regs.BC != 0)
		{
			regs.F |= 4;
			if ((regs.F & 0x40) == 0)
			{
				regs.PC -= 2;
				Tact += 5uL;
				regs.MW = (ushort)(regs.PC + 1);
			}
		}
	}

	private void ED_INDR(byte cmd)
	{
		regs.MW = (ushort)(regs.BC - 1);
		byte value = ReadPort(regs.BC);
		Tact += 4uL;
		WriteMemory(regs.HL--, value);
		Tact += 4uL;
		regs.B = ALU_DECR(regs.B);
		if (regs.B != 0)
		{
			regs.F |= 4;
			regs.PC -= 2;
			Tact += 5uL;
		}
		else
		{
			regs.F &= 251;
		}
	}

	private void ED_OTDR(byte cmd)
	{
		regs.B = ALU_DECR(regs.B);
		byte value = ReadMemory(regs.HL--, M1: false);
		Tact += 4uL;
		WritePort(regs.BC, value);
		Tact += 4uL;
		if (regs.B != 0)
		{
			regs.F |= 4;
			regs.PC -= 2;
			Tact += 5uL;
		}
		else
		{
			regs.F &= 251;
		}
		regs.F &= 254;
		if (regs.L == byte.MaxValue)
		{
			regs.F |= 1;
		}
		regs.MW = (ushort)(regs.BC - 1);
	}

	private void ED_INRC(byte cmd)
	{
		regs.MW = (ushort)(regs.BC + 1);
		byte b = ReadPort(regs.BC);
		Tact += 4uL;
		int num = (cmd & 0x38) >> 3;
		if (num != 6)
		{
			regs[num] = b;
		}
		regs.F = (byte)(log_f[b] | (regs.F & 1u));
	}

	private void ED_OUTCR(byte cmd)
	{
		regs.MW = (ushort)(regs.BC + 1);
		int num = (cmd & 0x38) >> 3;
		Tact += 3uL;
		if (num != 6)
		{
			WritePort(regs.BC, regs[num]);
		}
		else
		{
			WritePort(regs.BC, 0);
		}
		Tact++;
	}

	private void ED_ADCHLRR(byte cmd)
	{
		regs.MW = (ushort)(regs.HL + 1);
		int rR = (cmd & 0x30) >> 4;
		byte b = (byte)((uint)((regs.HL & 0xFFF) + (regs.GetPair(rR) & 0xFFF) + (regs.F & 1) >> 8) & 0x10u);
		uint num = (uint)((regs.HL & 0xFFFF) + (regs.GetPair(rR) & 0xFFFF) + (regs.F & 1));
		if ((num & 0x10000u) != 0)
		{
			b = (byte)(b | 1u);
		}
		if ((num & 0xFFFF) == 0)
		{
			b = (byte)(b | 0x40u);
		}
		int num2 = (short)regs.HL + (short)regs.GetPair(rR) + (regs.F & 1);
		if (num2 < -32768 || num2 >= 32768)
		{
			b = (byte)(b | 4u);
		}
		regs.HL = (ushort)num;
		regs.F = (byte)(b | (regs.H & 0xA8u));
		Tact += 7uL;
	}

	private void ED_SBCHLRR(byte cmd)
	{
		regs.MW = (ushort)(regs.HL + 1);
		int rR = (cmd & 0x30) >> 4;
		byte b = 2;
		b = (byte)(b | (byte)((uint)((regs.HL & 0xFFF) - (regs.GetPair(rR) & 0xFFF) - (regs.F & 1) >> 8) & 0x10u));
		uint num = (uint)((regs.HL & 0xFFFF) - (regs.GetPair(rR) & 0xFFFF) - (regs.F & 1));
		if ((num & 0x10000u) != 0)
		{
			b = (byte)(b | 1u);
		}
		if ((num & 0xFFFF) == 0)
		{
			b = (byte)(b | 0x40u);
		}
		int num2 = (short)regs.HL - (short)regs.GetPair(rR) - (regs.F & 1);
		if (num2 < -32768 || num2 >= 32768)
		{
			b = (byte)(b | 4u);
		}
		regs.HL = (ushort)num;
		regs.F = (byte)(b | (regs.H & 0xA8u));
		Tact += 7uL;
	}

	private void ED_LDRR_NN_(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num + 1);
		ushort num2 = ReadMemory(num, M1: false);
		Tact += 3uL;
		num2 = (ushort)(num2 + (ushort)(ReadMemory(regs.MW, M1: false) * 256));
		Tact += 3uL;
		regs.SetPair((cmd & 0x30) >> 4, num2);
	}

	private void ED_LD_NN_RR(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num + 1);
		ushort pair = regs.GetPair((cmd & 0x30) >> 4);
		WriteMemory(num, (byte)(pair & 0xFFu));
		Tact += 3uL;
		WriteMemory(regs.MW, (byte)(pair >> 8));
		Tact += 3uL;
	}

	private void ED_RETN(byte cmd)
	{
		IFF1 = IFF2;
		ushort num = ReadMemory(regs.SP, M1: false);
		Tact += 3uL;
		num = (ushort)(num + (ushort)(ReadMemory(++regs.SP, M1: false) * 256));
		Tact += 3uL;
		regs.SP++;
		regs.PC = num;
		regs.MW = num;
	}

	private void ED_IM(byte cmd)
	{
		byte b = (byte)((cmd & 0x18) >> 3);
		if (b < 2)
		{
			b = 1;
		}
		b = (IM = (byte)(b - 1));
	}

	private void ED_LDXRA(byte cmd)
	{
		if ((cmd & 8) == 0)
		{
			regs.I = regs.A;
		}
		else
		{
			regs.R = regs.A;
		}
		Tact++;
	}

	private void ED_LDAXR(byte cmd)
	{
		bool flag = (cmd & 8) == 0;
		if (flag)
		{
			regs.A = regs.I;
		}
		else
		{
			regs.A = regs.R;
		}
		regs.F = (byte)((log_f[regs.A] | (regs.F & 1u)) & 0xFFFFFFFBu);
		if (flag)
		{
			if (IFF1 && !INT)
			{
				regs.F |= 4;
			}
		}
		else if (IFF2 && !INT)
		{
			regs.F |= 4;
		}
		Tact++;
	}

	private void ED_RRD(byte cmd)
	{
		byte b = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		regs.MW = (ushort)(regs.HL + 1);
		WriteMemory(regs.HL, (byte)((regs.A << 4) | (b >> 4)));
		Tact += 3uL;
		Tact += 4uL;
		regs.A = (byte)((regs.A & 0xF0u) | (b & 0xFu));
		regs.F = (byte)(log_f[regs.A] | (regs.F & 1u));
	}

	private void ED_RLD(byte cmd)
	{
		byte b = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		regs.MW = (ushort)(regs.HL + 1);
		WriteMemory(regs.HL, (byte)((regs.A & 0xFu) | (uint)(b << 4)));
		Tact += 3uL;
		Tact += 4uL;
		regs.A = (byte)((regs.A & 0xF0u) | (uint)(b >> 4));
		regs.F = (byte)(log_f[regs.A] | (regs.F & 1u));
	}

	private void ED_NEG(byte cmd)
	{
		regs.F = sbcf[regs.A];
		regs.A = (byte)(-regs.A);
	}

	private void initExecED()
	{
		XFXOPDO[] array = new XFXOPDO[256];
		array[64] = ED_INRC;
		array[65] = ED_OUTCR;
		array[66] = ED_SBCHLRR;
		array[67] = ED_LD_NN_RR;
		array[68] = ED_NEG;
		array[69] = ED_RETN;
		array[70] = ED_IM;
		array[71] = ED_LDXRA;
		array[72] = ED_INRC;
		array[73] = ED_OUTCR;
		array[74] = ED_ADCHLRR;
		array[75] = ED_LDRR_NN_;
		array[76] = ED_NEG;
		array[77] = ED_RETN;
		array[78] = ED_IM;
		array[79] = ED_LDXRA;
		array[80] = ED_INRC;
		array[81] = ED_OUTCR;
		array[82] = ED_SBCHLRR;
		array[83] = ED_LD_NN_RR;
		array[84] = ED_NEG;
		array[85] = ED_RETN;
		array[86] = ED_IM;
		array[87] = ED_LDAXR;
		array[88] = ED_INRC;
		array[89] = ED_OUTCR;
		array[90] = ED_ADCHLRR;
		array[91] = ED_LDRR_NN_;
		array[92] = ED_NEG;
		array[93] = ED_RETN;
		array[94] = ED_IM;
		array[95] = ED_LDAXR;
		array[96] = ED_INRC;
		array[97] = ED_OUTCR;
		array[98] = ED_SBCHLRR;
		array[99] = ED_LD_NN_RR;
		array[100] = ED_NEG;
		array[101] = ED_RETN;
		array[102] = ED_IM;
		array[103] = ED_RRD;
		array[104] = ED_INRC;
		array[105] = ED_OUTCR;
		array[106] = ED_ADCHLRR;
		array[107] = ED_LDRR_NN_;
		array[108] = ED_NEG;
		array[109] = ED_RETN;
		array[110] = ED_IM;
		array[111] = ED_RLD;
		array[112] = ED_INRC;
		array[113] = ED_OUTCR;
		array[114] = ED_SBCHLRR;
		array[115] = ED_LD_NN_RR;
		array[116] = ED_NEG;
		array[117] = ED_RETN;
		array[118] = ED_IM;
		array[120] = ED_INRC;
		array[121] = ED_OUTCR;
		array[122] = ED_ADCHLRR;
		array[123] = ED_LDRR_NN_;
		array[124] = ED_NEG;
		array[125] = ED_RETN;
		array[126] = ED_IM;
		array[160] = ED_LDI;
		array[161] = ED_CPI;
		array[162] = ED_INI;
		array[163] = ED_OUTI;
		array[168] = ED_LDD;
		array[169] = ED_CPD;
		array[170] = ED_IND;
		array[171] = ED_OUTD;
		array[176] = ED_LDIR;
		array[177] = ED_CPIR;
		array[178] = ED_INIR;
		array[179] = ED_OTIR;
		array[184] = ED_LDDR;
		array[185] = ED_CPDR;
		array[186] = ED_INDR;
		array[187] = ED_OTDR;
		edopTABLE = array;
	}

	private void INA_NN_(byte cmd)
	{
		Tact += 2uL;
		ushort num = ReadMemory(regs.PC++, M1: false);
		Tact += 5uL;
		num = (ushort)(num + (ushort)(regs.A << 8));
		regs.MW = (ushort)((regs.A << 8) + num + 1);
		regs.A = ReadPort(num);
	}

	private void OUT_NN_A(byte cmd)
	{
		Tact += 2uL;
		ushort num = ReadMemory(regs.PC++, M1: false);
		regs.MW = (ushort)(((num + 1) & 0xFF) + (regs.A << 8));
		Tact += 4uL;
		num = (ushort)(num + (ushort)(regs.A << 8));
		WritePort(num, regs.A);
		Tact++;
	}

	private void DI(byte cmd)
	{
		IFF1 = false;
		IFF2 = IFF1;
	}

	private void EI(byte cmd)
	{
		IFF1 = true;
		IFF2 = true;
		BlockINT = true;
	}

	private void LDSPHL(byte cmd)
	{
		regs.SP = regs.HL;
		Tact += 2uL;
	}

	private void EX_SP_HL(byte cmd)
	{
		ushort sP = regs.SP;
		regs.MW = ReadMemory(sP, M1: false);
		Tact += 3uL;
		WriteMemory(sP, regs.L);
		Tact += 3uL;
		sP = (ushort)(sP + 1);
		regs.MW += (ushort)(ReadMemory(sP, M1: false) * 256);
		Tact += 3uL;
		WriteMemory(sP, regs.H);
		Tact += 3uL;
		regs.HL = regs.MW;
		Tact += 3uL;
	}

	private void JP_HL_(byte cmd)
	{
		regs.PC = regs.HL;
	}

	private void EXDEHL(byte cmd)
	{
		ushort hL = regs.HL;
		regs.HL = regs.DE;
		regs.DE = hL;
	}

	private void EXAFAF(byte cmd)
	{
		regs.EXAF();
	}

	private void EXX(byte cmd)
	{
		regs.EXX();
	}

	private void RLCA(byte cmd)
	{
		regs.F = (byte)(rlcaf[regs.A] | (regs.F & 0xC4u));
		int a = regs.A;
		a <<= 1;
		if (((uint)a & 0x100u) != 0)
		{
			a = (a | 1) & 0xFF;
		}
		regs.A = (byte)a;
	}

	private void RRCA(byte cmd)
	{
		regs.F = (byte)(rrcaf[regs.A] | (regs.F & 0xC4u));
		int a = regs.A;
		a = (((a & 1) == 0) ? (a >> 1) : ((a >> 1) | 0x80));
		regs.A = (byte)a;
	}

	private void RLA(byte cmd)
	{
		bool flag = (regs.F & 1) != 0;
		regs.F = (byte)(rlcaf[regs.A] | (regs.F & 0xC4u));
		regs.A = (byte)((uint)(regs.A << 1) & 0xFFu);
		if (flag)
		{
			regs.A |= 1;
		}
	}

	private void RRA(byte cmd)
	{
		bool flag = (regs.F & 1) != 0;
		regs.F = (byte)(rrcaf[regs.A] | (regs.F & 0xC4u));
		regs.A = (byte)(regs.A >> 1);
		if (flag)
		{
			regs.A |= 128;
		}
	}

	private void DAA(byte cmd)
	{
		regs.AF = daatab[regs.A + 256 * ((regs.F & 3) + ((regs.F >> 2) & 4))];
	}

	private void CPL(byte cmd)
	{
		regs.A ^= byte.MaxValue;
		regs.F = (byte)((regs.F & 0xD7u) | 0x12u | (regs.A & 0x28u));
	}

	private void SCF(byte cmd)
	{
		regs.F = (byte)((regs.F & 0xEDu) | (regs.A & 0x28u) | 1u);
	}

	private void CCF(byte cmd)
	{
		regs.F = (byte)(((regs.F & 0xEDu) | ((uint)(regs.F << 4) & 0x10u) | (regs.A & 0x28u)) ^ 1u);
	}

	private void DJNZ(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 4uL;
		regs.PC++;
		if (--regs.B != 0)
		{
			regs.MW = (regs.PC = (ushort)(regs.PC + (sbyte)num));
			Tact += 5uL;
		}
	}

	private void CALLNNNN(byte cmd)
	{
		regs.MW = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		regs.MW += (ushort)(ReadMemory(regs.PC, M1: false) * 256);
		Tact += 3uL;
		regs.PC++;
		Tact++;
		regs.SP--;
		WriteMemory(regs.SP, (byte)(regs.PC >> 8));
		Tact += 3uL;
		regs.SP--;
		WriteMemory(regs.SP, (byte)(regs.PC & 0xFFu));
		Tact += 3uL;
		regs.PC = regs.MW;
	}

	private void RET(byte cmd)
	{
		regs.MW = ReadMemory(regs.SP, M1: false);
		Tact += 3uL;
		regs.SP++;
		regs.MW += (ushort)(ReadMemory(regs.SP, M1: false) * 256);
		Tact += 3uL;
		regs.SP++;
		regs.PC = regs.MW;
	}

	private void JPNNNN(byte cmd)
	{
		regs.MW = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		regs.MW += (ushort)(ReadMemory(regs.PC, M1: false) * 256);
		Tact += 3uL;
		regs.PC = regs.MW;
	}

	private void JRNN(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		regs.MW = (regs.PC = (ushort)(regs.PC + (sbyte)num));
		Tact += 5uL;
	}

	private void JRXNN(byte cmd)
	{
		int num = (cmd & 0x18) >> 3;
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		int num3 = conds[num >> 1];
		int num4 = regs.AF & num3;
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			num4 ^= num3;
		}
		if (num4 == 0)
		{
			regs.MW = (regs.PC = (ushort)(regs.PC + (sbyte)num2));
			Tact += 5uL;
		}
	}

	private void RETX(byte cmd)
	{
		int num = (cmd & 0x38) >> 3;
		Tact++;
		int num2 = conds[num >> 1];
		int num3 = regs.AF & num2;
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			num3 ^= num2;
		}
		if (num3 == 0)
		{
			regs.MW = ReadMemory(regs.SP, M1: false);
			Tact += 3uL;
			regs.SP++;
			regs.MW += (ushort)(ReadMemory(regs.SP, M1: false) * 256);
			Tact += 3uL;
			regs.SP++;
			regs.PC = regs.MW;
		}
	}

	private void CALLXNNNN(byte cmd)
	{
		int num = (cmd & 0x38) >> 3;
		regs.MW = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		regs.MW += (ushort)(ReadMemory(regs.PC, M1: false) * 256);
		Tact += 3uL;
		regs.PC++;
		int num2 = conds[num >> 1];
		int num3 = regs.AF & num2;
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			num3 ^= num2;
		}
		if (num3 == 0)
		{
			Tact++;
			regs.SP--;
			WriteMemory(regs.SP, (byte)(regs.PC >> 8));
			Tact += 3uL;
			regs.SP--;
			WriteMemory(regs.SP, (byte)regs.PC);
			Tact += 3uL;
			regs.PC = regs.MW;
		}
	}

	private void JPXNN(byte cmd)
	{
		int num = (cmd & 0x38) >> 3;
		regs.MW = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		regs.MW += (ushort)(ReadMemory(regs.PC, M1: false) * 256);
		Tact += 3uL;
		regs.PC++;
		int num2 = conds[num >> 1];
		int num3 = regs.AF & num2;
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			num3 ^= num2;
		}
		if (num3 == 0)
		{
			regs.PC = regs.MW;
		}
	}

	private void RSTNN(byte cmd)
	{
		regs.SP--;
		Tact++;
		WriteMemory(regs.SP, (byte)(regs.PC >> 8));
		Tact += 3uL;
		regs.SP--;
		WriteMemory(regs.SP, (byte)regs.PC);
		Tact += 3uL;
		regs.MW = (ushort)(cmd & 0x38u);
		regs.PC = regs.MW;
	}

	private void PUSHRR(byte cmd)
	{
		int num = (cmd & 0x30) >> 4;
		ushort num2 = ((num != 3) ? regs.GetPair(num) : regs.AF);
		regs.SP--;
		Tact++;
		WriteMemory(regs.SP, (byte)(num2 >> 8));
		Tact += 3uL;
		regs.SP--;
		WriteMemory(regs.SP, (byte)(num2 & 0xFFu));
		Tact += 3uL;
	}

	private void POPRR(byte cmd)
	{
		int num = (cmd & 0x30) >> 4;
		ushort num2 = ReadMemory(regs.SP, M1: false);
		Tact += 3uL;
		regs.SP++;
		num2 = (ushort)(num2 | (ushort)(ReadMemory(regs.SP, M1: false) << 8));
		Tact += 3uL;
		regs.SP++;
		if (num == 3)
		{
			regs.AF = num2;
		}
		else
		{
			regs.SetPair(num, num2);
		}
	}

	private void ALUAN(byte cmd)
	{
		int num = (cmd & 0x38) >> 3;
		byte src = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		alualg[num](src);
	}

	private void ALUAR(byte cmd)
	{
		int index = cmd & 7;
		int num = (cmd & 0x38) >> 3;
		alualg[num](regs[index]);
	}

	private void ALUA_HL_(byte cmd)
	{
		int num = (cmd & 0x38) >> 3;
		byte src = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		alualg[num](src);
	}

	private void ADDHLRR(byte cmd)
	{
		regs.MW = (ushort)(regs.HL + 1);
		regs.HL = ALU_ADDHLRR(regs.HL, regs.GetPair((cmd & 0x30) >> 4));
		Tact += 7uL;
	}

	private void LDA_RR_(byte cmd)
	{
		ushort pair = regs.GetPair((cmd & 0x30) >> 4);
		regs.MW = (ushort)(pair + 1);
		regs.A = ReadMemory(pair, M1: false);
		Tact += 3uL;
	}

	private void LDA_NN_(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num + 1);
		regs.A = ReadMemory(num, M1: false);
		Tact += 3uL;
	}

	private void LDHL_NN_(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num + 1);
		ushort num2 = ReadMemory(num, M1: false);
		Tact += 3uL;
		num2 = (ushort)(num2 + (ushort)(ReadMemory(regs.MW, M1: false) * 256));
		Tact += 3uL;
		regs.HL = num2;
	}

	private void LD_RR_A(byte cmd)
	{
		WriteMemory(regs.GetPair((cmd & 0x30) >> 4), regs.A);
		regs.MH = regs.A;
		Tact += 3uL;
	}

	private void LD_NN_A(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(((num + 1) & 0xFF) + (regs.A << 8));
		WriteMemory(num, regs.A);
		regs.MH = regs.A;
		Tact += 3uL;
	}

	private void LD_NN_HL(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num + 1);
		WriteMemory(num, regs.L);
		Tact += 3uL;
		WriteMemory(regs.MW, regs.H);
		Tact += 3uL;
	}

	private void LDRRNNNN(byte cmd)
	{
		int rR = (cmd & 0x30) >> 4;
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num | (ushort)(ReadMemory(regs.PC, M1: false) << 8));
		Tact += 3uL;
		regs.PC++;
		regs.SetPair(rR, num);
	}

	private void LDRNN(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		regs[index] = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
	}

	private void LD_HL_NN(byte cmd)
	{
		byte value = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		WriteMemory(regs.HL, value);
		Tact += 3uL;
	}

	private void LDRdRs(byte cmd)
	{
		int index = cmd & 7;
		int index2 = (cmd & 0x38) >> 3;
		regs[index2] = regs[index];
	}

	private void LD_HL_R(byte cmd)
	{
		int index = cmd & 7;
		WriteMemory(regs.HL, regs[index]);
		Tact += 3uL;
	}

	private void LDR_HL_(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		regs[index] = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
	}

	private void DECRR(byte cmd)
	{
		int rR = (cmd & 0x30) >> 4;
		regs.SetPair(rR, (ushort)(regs.GetPair(rR) - 1));
		Tact += 2uL;
	}

	private void INCRR(byte cmd)
	{
		int rR = (cmd & 0x30) >> 4;
		regs.SetPair(rR, (ushort)(regs.GetPair(rR) + 1));
		Tact += 2uL;
	}

	private void DECR(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		regs[index] = ALU_DECR(regs[index]);
	}

	private void DEC_HL_(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		x = ALU_DECR(x);
		Tact++;
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void INCR(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		regs[index] = ALU_INCR(regs[index]);
	}

	private void INC_HL_(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		x = ALU_INCR(x);
		Tact++;
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void HALT(byte cmd)
	{
		HALTED = true;
	}

	private void initExec()
	{
		opTABLE = new XFXOPDO[256]
		{
			null, LDRRNNNN, LD_RR_A, INCRR, INCR, DECR, LDRNN, RLCA, EXAFAF, ADDHLRR,
			LDA_RR_, DECRR, INCR, DECR, LDRNN, RRCA, DJNZ, LDRRNNNN, LD_RR_A, INCRR,
			INCR, DECR, LDRNN, RLA, JRNN, ADDHLRR, LDA_RR_, DECRR, INCR, DECR,
			LDRNN, RRA, JRXNN, LDRRNNNN, LD_NN_HL, INCRR, INCR, DECR, LDRNN, DAA,
			JRXNN, ADDHLRR, LDHL_NN_, DECRR, INCR, DECR, LDRNN, CPL, JRXNN, LDRRNNNN,
			LD_NN_A, INCRR, INC_HL_, DEC_HL_, LD_HL_NN, SCF, JRXNN, ADDHLRR, LDA_NN_, DECRR,
			INCR, DECR, LDRNN, CCF, null, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDRdRs,
			LDR_HL_, LDRdRs, LDRdRs, null, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDR_HL_, LDRdRs,
			LDRdRs, LDRdRs, null, LDRdRs, LDRdRs, LDRdRs, LDR_HL_, LDRdRs, LDRdRs, LDRdRs,
			LDRdRs, null, LDRdRs, LDRdRs, LDR_HL_, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDRdRs,
			null, LDRdRs, LDR_HL_, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDRdRs, null,
			LDR_HL_, LDRdRs, LD_HL_R, LD_HL_R, LD_HL_R, LD_HL_R, LD_HL_R, LD_HL_R, HALT, LD_HL_R,
			LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDRdRs, LDR_HL_, null, ALUAR, ALUAR,
			ALUAR, ALUAR, ALUAR, ALUAR, ALUA_HL_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR,
			ALUAR, ALUAR, ALUA_HL_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR,
			ALUA_HL_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUA_HL_, ALUAR,
			ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUA_HL_, ALUAR, ALUAR, ALUAR,
			ALUAR, ALUAR, ALUAR, ALUAR, ALUA_HL_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR,
			ALUAR, ALUAR, ALUA_HL_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR,
			ALUA_HL_, ALUAR, RETX, POPRR, JPXNN, JPNNNN, CALLXNNNN, PUSHRR, ALUAN, RSTNN,
			RETX, RET, JPXNN, null, CALLXNNNN, CALLNNNN, ALUAN, RSTNN, RETX, POPRR,
			JPXNN, OUT_NN_A, CALLXNNNN, PUSHRR, ALUAN, RSTNN, RETX, EXX, JPXNN, INA_NN_,
			CALLXNNNN, null, ALUAN, RSTNN, RETX, POPRR, JPXNN, EX_SP_HL, CALLXNNNN, PUSHRR,
			ALUAN, RSTNN, RETX, JP_HL_, JPXNN, EXDEHL, CALLXNNNN, null, ALUAN, RSTNN,
			RETX, POPRR, JPXNN, DI, CALLXNNNN, PUSHRR, ALUAN, RSTNN, RETX, LDSPHL,
			JPXNN, EI, CALLXNNNN, null, ALUAN, RSTNN
		};
	}

	private void FX_LDSPHL(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.SP = regs.IX;
		}
		else
		{
			regs.SP = regs.IY;
		}
		Tact += 2uL;
	}

	private void FX_EX_SP_HL(byte cmd)
	{
		ushort sP = regs.SP;
		ushort num = ReadMemory(sP, M1: false);
		Tact += 3uL;
		if (FX == OPFX.IX)
		{
			WriteMemory(sP, regs.XL);
		}
		else
		{
			WriteMemory(sP, regs.YL);
		}
		Tact += 3uL;
		num = (ushort)(num + (ushort)(ReadMemory(sP = (ushort)(sP + 1), M1: false) * 256));
		Tact += 3uL;
		if (FX == OPFX.IX)
		{
			WriteMemory(sP, regs.XH);
			regs.IX = num;
		}
		else
		{
			WriteMemory(sP, regs.YH);
			regs.IY = num;
		}
		regs.MW = num;
		Tact += 6uL;
	}

	private void FX_JP_HL_(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.PC = regs.IX;
		}
		else
		{
			regs.PC = regs.IY;
		}
	}

	private void FX_PUSHIX(byte cmd)
	{
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		regs.SP--;
		Tact++;
		WriteMemory(regs.SP, (byte)(num >> 8));
		Tact += 3uL;
		regs.SP--;
		WriteMemory(regs.SP, (byte)(num & 0xFFu));
		Tact += 3uL;
	}

	private void FX_POPIX(byte cmd)
	{
		ushort num = ReadMemory(regs.SP, M1: false);
		Tact += 3uL;
		regs.SP++;
		num = (ushort)(num | (ushort)(ReadMemory(regs.SP, M1: false) << 8));
		Tact += 3uL;
		regs.SP++;
		if (FX == OPFX.IX)
		{
			regs.IX = num;
		}
		else
		{
			regs.IY = num;
		}
	}

	private void FX_ALUAXH(byte cmd)
	{
		byte src = ((FX != OPFX.IX) ? ((byte)(regs.IY >> 8)) : ((byte)(regs.IX >> 8)));
		alualg[(cmd & 0x38) >> 3](src);
	}

	private void FX_ALUAXL(byte cmd)
	{
		byte src = ((FX != OPFX.IX) ? ((byte)(regs.IY & 0xFFu)) : ((byte)(regs.IX & 0xFFu)));
		alualg[(cmd & 0x38) >> 3](src);
	}

	private void FX_ALUA_IX_(byte cmd)
	{
		int num = (cmd & 0x38) >> 3;
		ushort num2 = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num3 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num2 = (ushort)(num2 + (sbyte)num3);
		Tact += 5uL;
		byte src = ReadMemory(num2, M1: false);
		Tact += 3uL;
		alualg[num](src);
	}

	private void FX_ADDIXRR(byte cmd)
	{
		regs.MW = (ushort)(regs.IX + 1);
		ushort rde = ((cmd & 0x30) >> 4) switch
		{
			0 => regs.BC, 
			1 => regs.DE, 
			2 => (FX != OPFX.IX) ? regs.IY : regs.IX, 
			3 => regs.SP, 
			_ => throw new Exception("Error decode reg in FX_ADDIXRR!"), 
		};
		if (FX == OPFX.IX)
		{
			regs.IX = ALU_ADDHLRR(regs.IX, rde);
		}
		else
		{
			regs.IY = ALU_ADDHLRR(regs.IY, rde);
		}
		Tact += 7uL;
	}

	private void FX_DECIX(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.IX--;
		}
		else
		{
			regs.IY--;
		}
		Tact += 2uL;
	}

	private void FX_INCIX(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.IX++;
		}
		else
		{
			regs.IY++;
		}
		Tact += 2uL;
	}

	private void FX_LDIX_N_(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num + 1);
		ushort num2 = ReadMemory(num, M1: false);
		Tact += 3uL;
		num2 = (ushort)(num2 + (ushort)(ReadMemory(regs.MW, M1: false) * 256));
		Tact += 3uL;
		if (FX == OPFX.IX)
		{
			regs.IX = num2;
		}
		else
		{
			regs.IY = num2;
		}
	}

	private void FX_LD_NN_IX(byte cmd)
	{
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num2 = (ushort)(num2 + (ushort)(ReadMemory(regs.PC, M1: false) * 256));
		Tact += 3uL;
		regs.PC++;
		regs.MW = (ushort)(num2 + 1);
		WriteMemory(num2, (byte)num);
		Tact += 3uL;
		WriteMemory(regs.MW, (byte)(num >> 8));
		Tact += 3uL;
	}

	private void FX_LDIXNNNN(byte cmd)
	{
		ushort num = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num | (ushort)(ReadMemory(regs.PC, M1: false) << 8));
		Tact += 3uL;
		regs.PC++;
		if (FX == OPFX.IX)
		{
			regs.IX = num;
		}
		else
		{
			regs.IY = num;
		}
	}

	private void FX_DEC_IX_(byte cmd)
	{
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (sbyte)num2);
		Tact += 5uL;
		byte x = ReadMemory(num, M1: false);
		Tact += 3uL;
		x = ALU_DECR(x);
		Tact++;
		WriteMemory(num, x);
		Tact += 3uL;
	}

	private void FX_INC_IX_(byte cmd)
	{
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (sbyte)num2);
		Tact += 5uL;
		byte x = ReadMemory(num, M1: false);
		Tact += 3uL;
		x = ALU_INCR(x);
		Tact++;
		WriteMemory(num, x);
		Tact += 3uL;
	}

	private void FX_LD_IX_NN(byte cmd)
	{
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (sbyte)num2);
		Tact += 2uL;
		byte value = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		WriteMemory(num, value);
		Tact += 3uL;
	}

	private void FX_LD_IX_R(byte cmd)
	{
		int index = cmd & 7;
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (sbyte)num2);
		Tact += 5uL;
		WriteMemory(num, regs[index]);
		Tact += 3uL;
	}

	private void FX_LDR_IX_(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		ushort num = ((FX != OPFX.IX) ? regs.IY : regs.IX);
		ushort num2 = ReadMemory(regs.PC, M1: false);
		Tact += 3uL;
		regs.PC++;
		num = (ushort)(num + (sbyte)num2);
		Tact += 5uL;
		regs[index] = ReadMemory(num, M1: false);
		Tact += 3uL;
	}

	private void FX_LDHL(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XH = regs.XL;
		}
		else
		{
			regs.YH = regs.YL;
		}
	}

	private void FX_LDLH(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XL = regs.XH;
		}
		else
		{
			regs.YL = regs.YH;
		}
	}

	private void FX_LDRL(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		if (FX == OPFX.IX)
		{
			regs[index] = regs.XL;
		}
		else
		{
			regs[index] = regs.YL;
		}
	}

	private void FX_LDRH(byte cmd)
	{
		int index = (cmd & 0x38) >> 3;
		if (FX == OPFX.IX)
		{
			regs[index] = regs.XH;
		}
		else
		{
			regs[index] = regs.YH;
		}
	}

	private void FX_LDLR(byte cmd)
	{
		int index = cmd & 7;
		if (FX == OPFX.IX)
		{
			regs.XL = regs[index];
		}
		else
		{
			regs.YL = regs[index];
		}
	}

	private void FX_LDHR(byte cmd)
	{
		int index = cmd & 7;
		if (FX == OPFX.IX)
		{
			regs.XH = regs[index];
		}
		else
		{
			regs.YH = regs[index];
		}
	}

	private void FX_LDLNN(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XL = ReadMemory(regs.PC, M1: false);
		}
		else
		{
			regs.YL = ReadMemory(regs.PC, M1: false);
		}
		Tact += 3uL;
		regs.PC++;
	}

	private void FX_LDHNN(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XH = ReadMemory(regs.PC, M1: false);
		}
		else
		{
			regs.YH = ReadMemory(regs.PC, M1: false);
		}
		Tact += 3uL;
		regs.PC++;
	}

	private void FX_INCL(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XL = ALU_INCR(regs.XL);
		}
		else
		{
			regs.YL = ALU_INCR(regs.YL);
		}
	}

	private void FX_INCH(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XH = ALU_INCR(regs.XH);
		}
		else
		{
			regs.YH = ALU_INCR(regs.YH);
		}
	}

	private void FX_DECL(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XL = ALU_DECR(regs.XL);
		}
		else
		{
			regs.YL = ALU_DECR(regs.YL);
		}
	}

	private void FX_DECH(byte cmd)
	{
		if (FX == OPFX.IX)
		{
			regs.XH = ALU_DECR(regs.XH);
		}
		else
		{
			regs.YH = ALU_DECR(regs.YH);
		}
	}

	private void initExecFX()
	{
		fxopTABLE = new XFXOPDO[256]
		{
			null, LDRRNNNN, LD_RR_A, INCRR, INCR, DECR, LDRNN, RLCA, EXAFAF, FX_ADDIXRR,
			LDA_RR_, DECRR, INCR, DECR, LDRNN, RRCA, DJNZ, LDRRNNNN, LD_RR_A, INCRR,
			INCR, DECR, LDRNN, RLA, JRNN, FX_ADDIXRR, LDA_RR_, DECRR, INCR, DECR,
			LDRNN, RRA, JRXNN, FX_LDIXNNNN, FX_LD_NN_IX, FX_INCIX, FX_INCH, FX_DECH, FX_LDHNN, DAA,
			JRXNN, FX_ADDIXRR, FX_LDIX_N_, FX_DECIX, FX_INCL, FX_DECL, FX_LDLNN, CPL, JRXNN, LDRRNNNN,
			LD_NN_A, INCRR, FX_INC_IX_, FX_DEC_IX_, FX_LD_IX_NN, SCF, JRXNN, FX_ADDIXRR, LDA_NN_, DECRR,
			INCR, DECR, LDRNN, CCF, null, LDRdRs, LDRdRs, LDRdRs, FX_LDRH, FX_LDRL,
			FX_LDR_IX_, LDRdRs, LDRdRs, null, LDRdRs, LDRdRs, FX_LDRH, FX_LDRL, FX_LDR_IX_, LDRdRs,
			LDRdRs, LDRdRs, null, LDRdRs, FX_LDRH, FX_LDRL, FX_LDR_IX_, LDRdRs, LDRdRs, LDRdRs,
			LDRdRs, null, FX_LDRH, FX_LDRL, FX_LDR_IX_, LDRdRs, FX_LDHR, FX_LDHR, FX_LDHR, FX_LDHR,
			null, FX_LDHL, FX_LDR_IX_, FX_LDHR, FX_LDLR, FX_LDLR, FX_LDLR, FX_LDLR, FX_LDLH, null,
			FX_LDR_IX_, FX_LDLR, FX_LD_IX_R, FX_LD_IX_R, FX_LD_IX_R, FX_LD_IX_R, FX_LD_IX_R, FX_LD_IX_R, HALT, FX_LD_IX_R,
			LDRdRs, LDRdRs, LDRdRs, LDRdRs, FX_LDRH, FX_LDRL, FX_LDR_IX_, null, ALUAR, ALUAR,
			ALUAR, ALUAR, FX_ALUAXH, FX_ALUAXL, FX_ALUA_IX_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR,
			FX_ALUAXH, FX_ALUAXL, FX_ALUA_IX_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, FX_ALUAXH, FX_ALUAXL,
			FX_ALUA_IX_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, FX_ALUAXH, FX_ALUAXL, FX_ALUA_IX_, ALUAR,
			ALUAR, ALUAR, ALUAR, ALUAR, FX_ALUAXH, FX_ALUAXL, FX_ALUA_IX_, ALUAR, ALUAR, ALUAR,
			ALUAR, ALUAR, FX_ALUAXH, FX_ALUAXL, FX_ALUA_IX_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR,
			FX_ALUAXH, FX_ALUAXL, FX_ALUA_IX_, ALUAR, ALUAR, ALUAR, ALUAR, ALUAR, FX_ALUAXH, FX_ALUAXL,
			FX_ALUA_IX_, ALUAR, RETX, POPRR, JPXNN, JPNNNN, CALLXNNNN, PUSHRR, ALUAN, RSTNN,
			RETX, RET, JPXNN, null, CALLXNNNN, CALLNNNN, ALUAN, RSTNN, RETX, POPRR,
			JPXNN, OUT_NN_A, CALLXNNNN, PUSHRR, ALUAN, RSTNN, RETX, EXX, JPXNN, INA_NN_,
			CALLXNNNN, null, ALUAN, RSTNN, RETX, FX_POPIX, JPXNN, FX_EX_SP_HL, CALLXNNNN, FX_PUSHIX,
			ALUAN, RSTNN, RETX, FX_JP_HL_, JPXNN, EXDEHL, CALLXNNNN, null, ALUAN, RSTNN,
			RETX, POPRR, JPXNN, DI, CALLXNNNN, PUSHRR, ALUAN, RSTNN, RETX, FX_LDSPHL,
			JPXNN, EI, CALLXNNNN, null, ALUAN, RSTNN
		};
	}

	private void CB_RLC(byte cmd)
	{
		regs[cmd & 7] = ALU_RLC(regs[cmd & 7]);
	}

	private void CB_RRC(byte cmd)
	{
		regs[cmd & 7] = ALU_RRC(regs[cmd & 7]);
	}

	private void CB_RL(byte cmd)
	{
		regs[cmd & 7] = ALU_RL(regs[cmd & 7]);
	}

	private void CB_RR(byte cmd)
	{
		regs[cmd & 7] = ALU_RR(regs[cmd & 7]);
	}

	private void CB_SLA(byte cmd)
	{
		regs[cmd & 7] = ALU_SLA(regs[cmd & 7]);
	}

	private void CB_SRA(byte cmd)
	{
		regs[cmd & 7] = ALU_SRA(regs[cmd & 7]);
	}

	private void CB_SLL(byte cmd)
	{
		regs[cmd & 7] = ALU_SLL(regs[cmd & 7]);
	}

	private void CB_SRL(byte cmd)
	{
		regs[cmd & 7] = ALU_SRL(regs[cmd & 7]);
	}

	private void CB_BIT(byte cmd)
	{
		ALU_BIT(regs[cmd & 7], (cmd & 0x38) >> 3);
	}

	private void CB_RES(byte cmd)
	{
		regs[cmd & 7] &= (byte)(~(1 << ((cmd & 0x38) >> 3)));
	}

	private void CB_SET(byte cmd)
	{
		regs[cmd & 7] |= (byte)(1 << ((cmd & 0x38) >> 3));
	}

	private void CB_RLCHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RLC(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_RRCHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RRC(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_RLHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RL(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_RRHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RR(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_SLAHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SLA(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_SRAHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SRA(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_SLLHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SLL(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_SRLHL(byte cmd)
	{
		byte x = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SRL(x);
		WriteMemory(regs.HL, x);
		Tact += 3uL;
	}

	private void CB_BITHL(byte cmd)
	{
		byte src = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		ALU_BITMEM(src, (cmd & 0x38) >> 3);
	}

	private void CB_RESHL(byte cmd)
	{
		byte b = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		b = (byte)(b & (byte)(~(1 << ((cmd & 0x38) >> 3))));
		WriteMemory(regs.HL, b);
		Tact += 3uL;
	}

	private void CB_SETHL(byte cmd)
	{
		byte b = ReadMemory(regs.HL, M1: false);
		Tact += 3uL;
		Tact++;
		b = (byte)(b | (byte)(1 << ((cmd & 0x38) >> 3)));
		WriteMemory(regs.HL, b);
		Tact += 3uL;
	}

	private void FXCB_RLC(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RLC(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_RRC(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RRC(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_RL(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RL(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_RR(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RR(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SLA(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SLA(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SRA(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SRA(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SLL(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SLL(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SRL(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SRL(x);
		WriteMemory(adr, x);
		regs[cmd & 7] = x;
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_BIT(byte cmd, ushort adr)
	{
		FXCB_BITIX(cmd, adr);
	}

	private void FXCB_RES(byte cmd, ushort adr)
	{
		FXCB_RESIX(cmd, adr);
	}

	private void FXCB_SET(byte cmd, ushort adr)
	{
		FXCB_SETIX(cmd, adr);
	}

	private void FXCB_RLCIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RLC(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_RRCIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RRC(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_RLIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RL(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_RRIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_RR(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SLAIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SLA(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SRAIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SRA(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SLLIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SLL(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SRLIX(byte cmd, ushort adr)
	{
		byte x = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		x = ALU_SRL(x);
		WriteMemory(adr, x);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_BITIX(byte cmd, ushort adr)
	{
		byte src = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		ALU_BITMEM(src, (cmd & 0x38) >> 3);
		RegenMemory();
	}

	private void FXCB_RESIX(byte cmd, ushort adr)
	{
		byte b = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		b = (byte)(b & (byte)(~(1 << ((cmd & 0x38) >> 3))));
		WriteMemory(adr, b);
		Tact += 3uL;
		Tact++;
	}

	private void FXCB_SETIX(byte cmd, ushort adr)
	{
		byte b = ReadMemory(adr, M1: false);
		Tact += 3uL;
		Tact++;
		b = (byte)(b | (byte)(1 << ((cmd & 0x38) >> 3)));
		WriteMemory(adr, b);
		Tact += 3uL;
		Tact++;
	}

	private void initExecCB()
	{
		cbopTABLE = new XFXOPDO[256]
		{
			CB_RLC, CB_RLC, CB_RLC, CB_RLC, CB_RLC, CB_RLC, CB_RLCHL, CB_RLC, CB_RRC, CB_RRC,
			CB_RRC, CB_RRC, CB_RRC, CB_RRC, CB_RRCHL, CB_RRC, CB_RL, CB_RL, CB_RL, CB_RL,
			CB_RL, CB_RL, CB_RLHL, CB_RL, CB_RR, CB_RR, CB_RR, CB_RR, CB_RR, CB_RR,
			CB_RRHL, CB_RR, CB_SLA, CB_SLA, CB_SLA, CB_SLA, CB_SLA, CB_SLA, CB_SLAHL, CB_SLA,
			CB_SRA, CB_SRA, CB_SRA, CB_SRA, CB_SRA, CB_SRA, CB_SRAHL, CB_SRA, CB_SLL, CB_SLL,
			CB_SLL, CB_SLL, CB_SLL, CB_SLL, CB_SLLHL, CB_SLL, CB_SRL, CB_SRL, CB_SRL, CB_SRL,
			CB_SRL, CB_SRL, CB_SRLHL, CB_SRL, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT,
			CB_BITHL, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BITHL, CB_BIT,
			CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BITHL, CB_BIT, CB_BIT, CB_BIT,
			CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BITHL, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT,
			CB_BIT, CB_BIT, CB_BITHL, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT,
			CB_BITHL, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BITHL, CB_BIT,
			CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BIT, CB_BITHL, CB_BIT, CB_RES, CB_RES,
			CB_RES, CB_RES, CB_RES, CB_RES, CB_RESHL, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES,
			CB_RES, CB_RES, CB_RESHL, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES,
			CB_RESHL, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RESHL, CB_RES,
			CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RESHL, CB_RES, CB_RES, CB_RES,
			CB_RES, CB_RES, CB_RES, CB_RES, CB_RESHL, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES,
			CB_RES, CB_RES, CB_RESHL, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES, CB_RES,
			CB_RESHL, CB_RES, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SETHL, CB_SET,
			CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SETHL, CB_SET, CB_SET, CB_SET,
			CB_SET, CB_SET, CB_SET, CB_SET, CB_SETHL, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET,
			CB_SET, CB_SET, CB_SETHL, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET,
			CB_SETHL, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SETHL, CB_SET,
			CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SET, CB_SETHL, CB_SET, CB_SET, CB_SET,
			CB_SET, CB_SET, CB_SET, CB_SET, CB_SETHL, CB_SET
		};
		fxcbopTABLE = new FXCBOPDO[256]
		{
			FXCB_RLC, FXCB_RLC, FXCB_RLC, FXCB_RLC, FXCB_RLC, FXCB_RLC, FXCB_RLCIX, FXCB_RLC, FXCB_RRC, FXCB_RRC,
			FXCB_RRC, FXCB_RRC, FXCB_RRC, FXCB_RRC, FXCB_RRCIX, FXCB_RRC, FXCB_RL, FXCB_RL, FXCB_RL, FXCB_RL,
			FXCB_RL, FXCB_RL, FXCB_RLIX, FXCB_RL, FXCB_RR, FXCB_RR, FXCB_RR, FXCB_RR, FXCB_RR, FXCB_RR,
			FXCB_RRIX, FXCB_RR, FXCB_SLA, FXCB_SLA, FXCB_SLA, FXCB_SLA, FXCB_SLA, FXCB_SLA, FXCB_SLAIX, FXCB_SLA,
			FXCB_SRA, FXCB_SRA, FXCB_SRA, FXCB_SRA, FXCB_SRA, FXCB_SRA, FXCB_SRAIX, FXCB_SRA, FXCB_SLL, FXCB_SLL,
			FXCB_SLL, FXCB_SLL, FXCB_SLL, FXCB_SLL, FXCB_SLLIX, FXCB_SLL, FXCB_SRL, FXCB_SRL, FXCB_SRL, FXCB_SRL,
			FXCB_SRL, FXCB_SRL, FXCB_SRLIX, FXCB_SRL, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT,
			FXCB_BITIX, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BITIX, FXCB_BIT,
			FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BITIX, FXCB_BIT, FXCB_BIT, FXCB_BIT,
			FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BITIX, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT,
			FXCB_BIT, FXCB_BIT, FXCB_BITIX, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT,
			FXCB_BITIX, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BITIX, FXCB_BIT,
			FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BIT, FXCB_BITIX, FXCB_BIT, FXCB_RES, FXCB_RES,
			FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RESIX, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES,
			FXCB_RES, FXCB_RES, FXCB_RESIX, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES,
			FXCB_RESIX, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RESIX, FXCB_RES,
			FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RESIX, FXCB_RES, FXCB_RES, FXCB_RES,
			FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RESIX, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES,
			FXCB_RES, FXCB_RES, FXCB_RESIX, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES, FXCB_RES,
			FXCB_RESIX, FXCB_RES, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET,
			FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET, FXCB_SET, FXCB_SET,
			FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET,
			FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET,
			FXCB_SETIX, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET,
			FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET, FXCB_SET, FXCB_SET,
			FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SET, FXCB_SETIX, FXCB_SET
		};
	}

	public static string GetMnemonic(MEMREADER MemReader, int Addr, bool Hex, out int MnemLength)
	{
		int num = 0;
		byte b = MemReader((ushort)(Addr + num));
		MnemLength = 1;
		string text = "*prefix*";
		int num2 = 0;
		string text2;
		if (b == 203)
		{
			num++;
			MnemLength++;
			text2 = CBhZ80Code[MemReader((ushort)(Addr + num))];
		}
		else if (b == 237)
		{
			num++;
			MnemLength++;
			text2 = EDhZ80Code[MemReader((ushort)(Addr + num))];
			if (text2.Length == 0)
			{
				text2 = "*NOP";
			}
		}
		else if (b == 221 || b == 253)
		{
			while (true)
			{
				b = MemReader((ushort)(Addr + num));
				text = ((b != 221) ? "IY" : "IX");
				num++;
				num2 = 1;
				MnemLength++;
				if (MemReader((ushort)(Addr + num)) == 203)
				{
					num++;
					MnemLength++;
					num2 = 0;
					text2 = DDFDCBhZ80Code[MemReader((ushort)(Addr + num + 1))];
					if (text2.Length == 0)
					{
						MnemLength++;
					}
					break;
				}
				if (MemReader((ushort)(Addr + num)) == 237)
				{
					num++;
					MnemLength++;
					text2 = EDhZ80Code[MemReader((ushort)(Addr + num))];
					if (text2.Length == 0)
					{
						text2 = "*NOP";
					}
					if (text2[0] != '*')
					{
						text2 = "*" + text2;
					}
					break;
				}
				if (MemReader((ushort)(Addr + num)) != 221 && MemReader((ushort)(Addr + num)) != 253)
				{
					text2 = DDFDhZ80Code[MemReader((ushort)(Addr + num))];
					break;
				}
			}
			if (text2.Length == 0)
			{
				text2 = "*" + DirectZ80Code[MemReader((ushort)(Addr + num))];
			}
		}
		else
		{
			text2 = DirectZ80Code[MemReader((ushort)(Addr + num))];
		}
		if (text2.IndexOf("$") < 0)
		{
			return text2;
		}
		do
		{
			if (text2.IndexOf("$R") >= 0)
			{
				int num3 = text2.IndexOf("$R");
				if (text2.Length <= num3 + 1 + 1)
				{
					text2 = text2.Remove(num3, 2);
					text2 = text2.Insert(num3, text);
				}
				else if (text2[num3 + 2] == 'L' || text2[num3 + 2] == 'H')
				{
					text2 = text2.Remove(num3, 2);
					text2 = text2.Insert(num3, "" + text[1]);
				}
				else
				{
					text2 = text2.Remove(num3, 2);
					text2 = text2.Insert(num3, text);
				}
			}
			if (text2.IndexOf("$PLUS") >= 0)
			{
				sbyte b2 = (sbyte)MemReader((ushort)(Addr + (num + num2)));
				int num4 = b2;
				if (b2 < 0)
				{
					num4 = -num4;
				}
				string value = ((b2 < 0) ? ((!Hex) ? ("-" + num4) : ("-#" + num4.ToString("X2"))) : ((!Hex) ? ("+" + num4) : ("+#" + num4.ToString("X2"))));
				int num3 = text2.IndexOf("$PLUS");
				text2 = text2.Remove(num3, 5);
				text2 = text2.Insert(num3, value);
				MnemLength++;
				num++;
			}
			if (text2.IndexOf("$S") >= 0)
			{
				byte b3 = MemReader((ushort)(Addr + num));
				string value = ((b3 & 0x38) >> 3).ToString();
				int num3 = text2.IndexOf("$S");
				text2 = text2.Remove(num3, 2);
				text2 = text2.Insert(num3, value);
			}
			if (text2.IndexOf("$W") >= 0)
			{
				ushort num5 = (ushort)(MemReader((ushort)(Addr + num + 1)) + 256 * MemReader((ushort)(Addr + num + 2)));
				string value = ((!Hex) ? num5.ToString() : ("#" + num5.ToString("X4")));
				int num3 = text2.IndexOf("$W");
				text2 = text2.Remove(num3, 2);
				text2 = text2.Insert(num3, value);
				MnemLength += 2;
			}
			if (text2.IndexOf("$N") >= 0)
			{
				byte b4 = MemReader((ushort)(Addr + num + 1));
				string value = ((!Hex) ? b4.ToString() : ("#" + b4.ToString("X2")));
				int num3 = text2.IndexOf("$N");
				text2 = text2.Remove(num3, 2);
				text2 = text2.Insert(num3, value);
				MnemLength++;
			}
			if (text2.IndexOf("$T") >= 0)
			{
				byte b5 = MemReader((ushort)(Addr + num));
				int num6 = ((b5 & 0x38) >> 3) * 8;
				string value = ((!Hex) ? num6.ToString() : ("#" + num6.ToString("X2")));
				int num3 = text2.IndexOf("$T");
				text2 = text2.Remove(num3, 2);
				text2 = text2.Insert(num3, value);
			}
			if (text2.IndexOf("$DIS") >= 0)
			{
				sbyte b6 = (sbyte)MemReader((ushort)(Addr + num + 1));
				int num7 = Addr + 2 + num + b6;
				num7 = (ushort)num7;
				string value = ((!Hex) ? num7.ToString() : ("#" + num7.ToString("X4")));
				int num3 = text2.IndexOf("$DIS");
				text2 = text2.Remove(num3, 4);
				text2 = text2.Insert(num3, value);
				MnemLength++;
			}
		}
		while (text2.IndexOf("$") >= 0);
		return text2;
	}

	private void ALU_ADDR(byte src)
	{
		regs.F = adcf[regs.A + src * 256];
		regs.A += src;
	}

	private void ALU_ADCR(byte src)
	{
		byte b = (byte)(regs.F & 1u);
		regs.F = adcf[regs.A + src * 256 + 65536 * b];
		regs.A += (byte)(src + b);
	}

	private void ALU_SUBR(byte src)
	{
		regs.F = sbcf[regs.A * 256 + src];
		regs.A -= src;
	}

	private void ALU_SBCR(byte src)
	{
		byte b = (byte)(regs.F & 1u);
		regs.F = sbcf[regs.A * 256 + src + 65536 * b];
		regs.A -= (byte)(src + b);
	}

	private void ALU_ANDR(byte src)
	{
		regs.A &= src;
		regs.F = (byte)(log_f[regs.A] | 0x10u);
	}

	private void ALU_XORR(byte src)
	{
		regs.A ^= src;
		regs.F = log_f[regs.A];
	}

	private void ALU_ORR(byte src)
	{
		regs.A |= src;
		regs.F = log_f[regs.A];
	}

	private void ALU_CPR(byte src)
	{
		regs.F = cpf[regs.A * 256 + src];
	}

	private byte ALU_INCR(byte x)
	{
		regs.F = (byte)(incf[x] | (regs.F & 1u));
		x = (byte)(x + 1);
		return x;
	}

	private byte ALU_DECR(byte x)
	{
		regs.F = (byte)(decf[x] | (regs.F & 1u));
		x = (byte)(x - 1);
		return x;
	}

	private ushort ALU_ADDHLRR(ushort rhl, ushort rde)
	{
		regs.F = (byte)(regs.F & 0xFFFFFFC4u);
		regs.F |= (byte)(((rhl & 0xFFF) + (rde & 0xFFF) >> 8) & 0x10);
		uint num = (uint)((rhl & 0xFFFF) + (rde & 0xFFFF));
		if ((num & 0x10000u) != 0)
		{
			regs.F |= 1;
		}
		regs.F |= (byte)((byte)((num >> 8) & 0xFF) & 0x28);
		return (ushort)(num & 0xFFFFu);
	}

	private byte ALU_RLC(int x)
	{
		regs.F = rlcf[x];
		x <<= 1;
		if (((uint)x & 0x100u) != 0)
		{
			x = (x | 1) & 0xFF;
		}
		return (byte)x;
	}

	private byte ALU_RRC(int x)
	{
		regs.F = rrcf[x];
		x = (((x & 1) == 0) ? (x >> 1) : ((x >> 1) | 0x80));
		return (byte)x;
	}

	private byte ALU_RL(int x)
	{
		if (((uint)regs.F & (true ? 1u : 0u)) != 0)
		{
			regs.F = rl1[x];
			x <<= 1;
			x++;
		}
		else
		{
			regs.F = rl0[x];
			x <<= 1;
		}
		return (byte)((uint)x & 0xFFu);
	}

	private byte ALU_RR(int x)
	{
		if (((uint)regs.F & (true ? 1u : 0u)) != 0)
		{
			regs.F = rr1[x];
			x >>= 1;
			x += 128;
		}
		else
		{
			regs.F = rr0[x];
			x >>= 1;
		}
		return (byte)((uint)x & 0xFFu);
	}

	private byte ALU_SLA(int x)
	{
		regs.F = rl0[x];
		x <<= 1;
		return (byte)x;
	}

	private byte ALU_SRA(int x)
	{
		regs.F = sraf[x];
		x = (x >> 1) + (x & 0x80);
		return (byte)x;
	}

	private byte ALU_SLL(int x)
	{
		regs.F = rl1[x];
		x <<= 1;
		x++;
		return (byte)((uint)x & 0xFFu);
	}

	private byte ALU_SRL(int x)
	{
		regs.F = rr0[x];
		x >>= 1;
		return (byte)x;
	}

	private void ALU_BIT(byte src, int bit)
	{
		regs.F = (byte)(log_f[src & (1 << bit)] | 0x10u | (regs.F & 1u) | (src & 0x28u));
	}

	private void ALU_BITMEM(byte src, int bit)
	{
		regs.F = (byte)(log_f[src & (1 << bit)] | 0x10u | (regs.F & 1u));
		regs.F = (byte)((regs.F & 0xD7u) | (regs.MH & 0x28u));
	}

	private void ALU_INIT()
	{
		alualg = new ALUALGORITHM[8] { ALU_ADDR, ALU_ADCR, ALU_SUBR, ALU_SBCR, ALU_ANDR, ALU_XORR, ALU_ORR, ALU_CPR };
		alulogic = new ALUALGORITHM[8] { RLCA, RRCA, RLA, RRA, DAA, CPL, SCF, CCF };
		make_adc();
		make_sbc();
		make_log();
		make_rot();
	}

	private void make_log()
	{
		log_f = new byte[256];
		for (int i = 0; i < 256; i++)
		{
			byte b = (byte)((uint)i & 0xA8u);
			byte b2 = 4;
			for (int num = 128; num != 0; num /= 2)
			{
				if ((i & num) == num)
				{
					b2 = (byte)(b2 ^ 4u);
				}
			}
			log_f[i] = (byte)(b | b2);
		}
		log_f[0] |= 64;
	}

	private void make_sbc()
	{
		sbcf = new byte[131072];
		cpf = new byte[65536];
		cpf8b = new byte[65536];
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 256; j++)
			{
				for (int k = 0; k < 256; k++)
				{
					int num = j - k - i;
					byte b = (byte)((uint)num & 0xA8u);
					if ((num & 0xFF) == 0)
					{
						b = (byte)(b | 0x40u);
					}
					if (((uint)num & 0x10000u) != 0)
					{
						b = (byte)(b | 1u);
					}
					int num2 = (sbyte)j - (sbyte)k - i;
					if (num2 >= 128 || num2 < -128)
					{
						b = (byte)(b | 4u);
					}
					if (((uint)((j & 0xF) - (num & 0xF) - i) & 0x10u) != 0)
					{
						b = (byte)(b | 0x10u);
					}
					b = (byte)(b | 2u);
					sbcf[i * 65536 + j * 256 + k] = b;
				}
			}
		}
		for (int l = 0; l < 65536; l++)
		{
			cpf[l] = (byte)((sbcf[l] & 0xD7u) | ((uint)l & 0x28u));
			byte b2 = (byte)((l >> 8) - (l & 0xFF) - ((sbcf[l] & 0x10) >> 4));
			cpf8b[l] = (byte)((sbcf[l] & 0xD2) + (b2 & 8) + ((b2 << 4) & 0x20));
		}
	}

	private void make_adc()
	{
		adcf = new byte[131072];
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 256; j++)
			{
				for (int k = 0; k < 256; k++)
				{
					uint num = (uint)(j + k + i);
					byte b = 0;
					if ((num & 0xFF) == 0)
					{
						b = (byte)(b | 0x40u);
					}
					b = (byte)(b | (byte)(num & 0xA8u));
					if (num >= 256)
					{
						b = (byte)(b | 1u);
					}
					if (((uint)((j & 0xF) + (k & 0xF) + i) & 0x10u) != 0)
					{
						b = (byte)(b | 0x10u);
					}
					int num2 = (sbyte)j + (sbyte)k + i;
					if (num2 >= 128 || num2 <= -129)
					{
						b = (byte)(b | 4u);
					}
					adcf[i * 65536 + j * 256 + k] = b;
				}
			}
		}
	}

	private void make_rot()
	{
		rlcaf = new byte[256];
		rrcaf = new byte[256];
		for (int i = 0; i < 256; i++)
		{
			rlcaf[i] = (byte)(rlcf[i] & 0x3Bu);
		}
		for (int j = 0; j < 256; j++)
		{
			rrcaf[j] = (byte)(rrcf[j] & 0x3Bu);
		}
	}
}
